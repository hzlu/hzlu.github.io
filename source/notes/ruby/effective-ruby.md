---
title: 改善 Ruby 程序的建议
type: notes
order: 16
category: Ruby
---

+ 除了false和nil外所有值都表示真值
+ Ruby的0值也是真值
+ 如果需要区分FALSE和nil，可以使用nil?方法或"=="操作符并将false作为左操作对象
+ 当使用include方法来将模块引入类时，会创建一个单例类并将它插入类体系中，最后包含的模块最先访问到。
+ 模块永远不会重载类中的方法
+ ancestors方法返回组成继承体系的所有类和模块的数组，只能在类和模块上被调用，并会跳过单例类。
+ included_modules方法返回和ancestors方法一样的数组，不过其中所有的类会被过滤掉。
+ 使用`class << obj`打开单例类
+ super其实是Ruby的关键字，如果给它添加括号或参数，它就表现得像一个方法；如果直接使用，super在调用目标方法时将宿主方法的所有参数全部传递过去。
+ 调用super时，它从继承体系的上一层寻找同名方法，而不是简单的从超类开始。
+ 如果不在类中定义initialize方法，定义的类将从BasicObject类中继承默认实现。
+ 当使用dup或clone创建对象副本时，可以在类中定义initialize_copy方法对新创建的副本对象执行特别的逻辑。Ruby会自动私有该方法。方法接受原对象作为参数。
+ Ruby调用setter方法时要求存在一个显式的接收者，否则就是一个简单的变量赋值
+ 在处理结构化数据时，如果创建一个新类不那么合适时，推荐使用Struct而非Hash，Struct::new方法还能接收一个可选块，定义实例方法和类方法。
+ 将Struct::new的返回值赋给常量，并像类一样使用它。
+ 如果用来创建命名空间的模块已经在前面定义过，那么可以在类定义中直接使用模块名和类路径分隔符
+ 常量查找：先检查当前词法作用域，如果没有找到常量将循着继承体系继续寻找
+ dup只会拷贝对象的tainted状态，clone拷贝对象的被冻结frozen和受污染tainted状态，clone会拷贝对象的单例类
+ 通过protected共享私有状态，一个对象的protected方法若要被显式接收者调用，除非该对象与接收者是同类对象或其具有相同的定义该protected方法的超类。
+ 类变量`@@a`的通常用途是实现单例模式（不同于单例类，单例模式：类只有一个实例）。由于类变量会被所有子类共享，这些类的任何实例对象都可以访问并修改这些共享的类变量，因此应该使用类的实例变量。
