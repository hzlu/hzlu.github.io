---
title: APUE 进程环境
tags:
  - unix
categories:
  - unix
date: 2017-10-11 15:40:12
---


- 进程ID 0 为内核交换进程使用
- init进程进程ID 为1
- init进程的程序文件是 `/etc/init` 或 `/sbin/init`
- 此进程负责在自举后启动一个UNIX系统
- 通常会读取与系统有关的初始化文件 `/etc/init.d/`中的文件 `/etc/inittab` `/etc/rc*` 等文件
- 将系统引导到一个状态，init进程决不会终止
- 它会成为所有孤儿进程的父进程
- fork 之后是父进程先执行还是子进程先执行都是不确定的，取决于内核使用的调度算法
- fork 会复制打开的文件描述符，父子进程的每个相同的文件描述符共享一个文件表项
- fork 之后处理文件描述符有两种常见情况：
  + 父进程等待子进程完成。父进程无需对其描述符做任何处理，子进程终止后，共享描述符的文件偏移量都执行了更新
  + 父子进程各自执行不同的程序段。fork之后各自关闭不需要使用的文件描述符，这样就不会干扰到对方，这是网络服务进程中经常使用的
- fork有两种用法：
  + 父进程希望复制自己，使父子进程同时执行不同的代码段，常见于网络服务进程
  + 一个进程要执行一个不同的程序，常见于shell，子进程fork后立即调用exec（fork后执行exec组合成一个称为 spawn）
- vfork 和 fork 一样都创建一个子进程，但它不降父进程的地址空间完全复制到子进程中
- 因为vfork的子进程会立即调用exec（或 exit）
- vfork保证子进程先运行，在子进程调用后父进程才可能被调度运行
-


## main函数执行

```c
int main(int argc, char *argv[]);
```

- 内核在调用main前先调用一个特殊的 *启动例程*
- 启动例程从内核取得 *命令行参数* 和 *环境变量值*
- 启动例程被指定为程序的起始地址

## 进程终止 termination

- 正常终止
  + 从main返回
  + 调用exit
  + 调用 _exit 或 _Exit
  + 最后一个线程从其启动例程返回
  + 最后一个线程调用 pthread_exit
- 异常终止
  + 调用abort
  + 接到一个信号并终止
  + 最后一个线程对取消请求做出响应

启动例程常常用汇编编写，如果用C代码表示可能是：

  exit(main(argc, argv));

### exit 函数

```c
#include <stdlib.h>
void exit(int status);
void _Exit(int status);

#include <unistd.h>
void _exit(int status);
```

- _exit 和 _Exit 函数会立即进入内核
- exit则先执行一些清除处理（执行终止处理程序，关闭所有标准IO流）然后进入内核
- 三个函数都带有一个整型参数，终止状态，退出状态
- 终止状态未定义
  + 调用exit时不带终止状态
  + main执行一个不带返回值的return
  + main没有声明返回整型
- 终止状态为0
  + 返回类型声明为整型，main最后一条语句返回，或隐式返回

### atexit 函数

一个进程可以登记多达32个函数，这些函数由exit自动调用，这些函数称为 *终止处理程序* exit handler

```c
#include <stdlib.h>

int atexit(void (*func)(void));
```

- 参数是一个函数地址
- 无需传递任何参数
- 也不期望返回值
- 调用顺序与登记顺序 *相反*
- 多次登记多次调用

![](/images/C程序启动和终止.jpeg)

> 内核使程序执行的唯一方法是调用一个 exec 函数
> 进程自愿终止的唯一方法是显式或隐式（通过exit）调用 _exit 或 _Exit
> 进程也可非自愿由信号终止

## 命令行参数

- 执行一个程序时， *调用exec的进程* 可将命令行参数传递给该新程序
- argv[argc] 是一个空指针 `for(i = 0; argv[i] != NULL; i++)`
- argv[0] 是程序名

## 环境表

- 每个程序都会接收到一张环境表
- 环境表是一个字符指针数组
- 每个指针包含一个以null结束的c字符串地址
- 全局变量environ包含该指针数组的地址
- `extern char **environ;`
- environ 称为环境指针
- 指针数组为环境表
- **环境** 由 *name=value* 这样的字符串组成
- 通常用 `getenv` 和 `putenv` 函数来访问特定的环境变量

![](/images/环境表.jpeg)

## C程序存储空间布局

- 正文段 由CPU执行的机器指令部分，只读，可共享
- 初始化数据段 包含了程序中需要明确赋初值的变量
- 非初始化数据段 通常称为 bss段
  + 内核将此段中数据初始化为0或空指针
  + 出现在函数外的C声明 `long sum[1000];` 使此变量存放在非初始化数据段中
- 栈
  + 自动变量
  + 每次函数调用时所需保存的信息
  + 每次函数调用时，函数的 *返回地址* 以及调用者的 *环境信息* 都存放在栈中
  + 递归函数每次调用自身，就使用一个新的栈帧
- 堆
  + 在堆中进行动态存储分配
  + 堆位于非初始化数据段和栈之间

![](/images/程序存储空间逻辑分布.jpeg)

堆顶和栈底之间未用的虚拟地址空间很大

> size 命令报告程序正文段，数据段和bss段的长度（字节单位）

## 共享库

- 共享库使得可执行文件不再需要包含公用的库例程
- 只需要在所有进程都可引用的存储区中维护这种库例程的副本
- 用动态链接方法将程序与共享库函数相链接
- 减少了可执行文件的长度，但增加了运行时间开销

## 存储器分配

三个用于存储空间动态分配的函数

- malloc 分配指定字节数的存储区，初始值不确定
- calloc 为 *指定数量* 具有 *指定长度* 的对象分配空间，初始为0
- realloc 更改以前分配区的长度，新增区域内的初始值不确定

```c
#include <stdlib.h>

void *malloc(size_t size);
void *calloc(size_t nobj, size_t size);
void *realloc(void *ptr, size_t newsize);

void free(void *ptr);
```

- 返回通用指针 `void*`，free函数释放的空间通常送入 *可用存储区池*
- 分配例程通常用 `sbrk` 系统调用实现，该系统调用扩充或缩小进程的 *堆*
- 已分配区比所要求的要稍大一些，用来记录管理信息
- 在已分配区起始位置之前写会重写本块的管理记录，在尾端进行写操作会重写后一个块的管理记录
- 其他可能产生的错误：
  + 释放一个已经释放的块
  + 调用free时所用的指针不是三个alloc函数的返回值
  + 调用malloc却忘了调用free会造成泄露

## 环境变量

- 内核不查看这些字符串，它们的解释完全取决于应用程序

```c
#include <stdlib.h>

char *getenv(const char *name);
```

返回指针，指向环境字符串`name=value` 中的value，应该使用getenv而不是直接访问environ

```c
int putenv(char *str)
int setenv(const char *name, const char *value, int rewrite);
int unsetenv(const char *name);
```

- putenv 是取形式为 `name=value` 的字符串，将其放入环境表中
- setenv 将name设置为value，如果在环境中name已经存在，如果rewrite非0则重写，rewrite为0则不变
- unsetenv 删除name的定义

### 修改环境表的操作

- 环境表和环境字符串存放在进程存储空间的顶部，栈之上
- 修改一个现有的name
- 增加一个name，操作更复杂

## setjmp 和 longjmp函数

## getrlimit 和 setrlimit 函数

- 每个进程都有一组资源限制
- 任何一个进程都可将一个软限制更改为小于或等于其硬限制的值
- 任何一个进程都可降低其硬限制值，但必须大于或等于其软限制值，这种降低对普通用户而言不可逆
- 只有超级用户进程能提高硬限制值


