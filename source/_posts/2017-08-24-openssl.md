---
title: OpenSSL 用法备忘
tags:
  - openssl
categories:
  - 命令行工具
date: 2017-08-24 16:06:30
---



- 用对方的公钥来加密，发给对方后，对方用私钥解密
- 用自己的私钥签名，对方收到用，用我的公钥来验证


## SSL 协议的握手过程

1. Client 发送协议版本号、随机数random1、支持的加密算法 ===> Server
2. Server 确认双方使用的加密算法 encryption 、给出数字证书 cert 以及生成一个随机数 random2 ===> Client
3. Client 确认cert 有效，再生成一个随机数 random3 并用cert中的公钥对其加密 encrypt_random3 ===> Server (Client 握手结束通知)
4. Server 用自己的私钥解密 encrypt_random3 得到 random3 (Server 握手结束通知)

双方使用确定的加密算法 encryption 对 random1 random2 random3 加密生成对话密钥 session_key ，这个session_key 对接下来的对话过程进行对称加密

## 对称加密

### enc 子命令

用于对称加密

加密，要求使用者输入密码

```bash
openssl enc -e -des3 -a -salt -in foo -out foo.encrypt
```

- `-e` 进行加密操作
- `-des3` 加密算法 `-aes256`
- `-in` 输入文件
- `-out` 输出文件

解密，要求使用者输入密码

```bash
openssl enc -d -des3 -a -salt -in foo.encrypt -out foo.decrypt
```

- `-d` 进行解密操作

### rand 子命令

用于生成随机数


```bash
openssl rand -base64 6
openssl rand -hex 30
```

## 非对称加密

### genrsa 子命令

生成私钥

```bash
openssl genrsa -out private_key.pem 1024
```

以私钥生成对应公钥


```bash
openssl rsa -in private_key.pem -out public_key.pem -outform PEM -pubout
```

### rsautl 子命令

公钥加密

```bash
openssl rasutl -encrypt -inkey public_key.pem -pubin -in test.txt -out test.txt.encrypt
```

私钥解密

```bash
openssl rasutl -decrypt -inkey private_key.pem -in test.txt.encrypt -out test.txt.decrypt
```

### 大文件加密

这种方式无法对任意大小的文件加密，文件太大会报错，可以用另一种方式对大文件进行非对称加密：

- 产生随机数，以随机数作为密码对大文件进行对称加密
- 然后把随机数密码进行非对称加密

```bash
openssl rand -base64 64 > key.bin
openssl enc -aes-256-cbc -salt -in test.txt -out test.txt.encrypt -pass file:key.bin
open rsautl -encrypt -inkey public_key.pem -pubin -in key.bin -out key.bin.encrypt
```

解密

```bash
openssl rsautl -decrypt -inkey private_key.pem -in key.bin.encrypt -out key.bin
openssl enc -d -aes-256-cbc -in test.txt.encrypt -out test.txt -pass file:key.bin
```

## 私有CA

### 构建私有CA

> PKI public key infrastructure 公钥基础建设

```bash
mkdir -p /etc/pki/CA/private

# 生成私钥
openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096

# 生成自签证书 -x509 生成自签格式证书，专用于创建私有CA
openssl req -new -x509 \
            -key /etc/pki/CA/private/cakey.pem\
            -out /etc/pki/CA/cacert.pem\
            -days 3655

# 为CA 提供需要的目录和文件
mkdir -pv /etc/pki/CA/{certs,crl,newcerts}
touch /etc/pki/CA/{serial,index.txt}
echo 01 > /etc/pki/CA/serial
```

### 向CA请求签署证书

> 第一步，生成私钥
>
> 第二步，生成证书签署请求 Certificate Signing Request CSR
>
> 第三步，把请求发送到CA主机
>
> 第四步，在CA主机上签署生成证书
>
> 第五步，把生成的证书发送到目标主机上


```bash
mkdir -p /etc/httpd/ssl && cd /etc/httpd/ssl

openssl genrsa -out /etc/httpd/ssl/httpd.key 2048

openssl req -new -key httpd.key -out httpd.csr -days 365 # 生成签署请求

scp httpd.csr foo@ca:/etc/pki/ca/certs # 把请求发送到CA服务器上

openssl ca -in httpd.csr -out httpd.crt -days 365 # 在CA上签署证书请求

scp cer.crt foo@host:/etc/httpd/ssl # 把签署证书拷贝回请求的主机上

openssl x509 -in httpd.crt -noout -serial -subject # 查看证书中的信息 -serial 查看序列号 -subject 查看主体信息
```

### 吊销证书

在 CA 服务器上找到证书的序列号 serial

需要对比客户提交的 serial 和 subject 信息与 CA 本机数据库 index.txt 中存储的是否一致

> ubuntu@ubuntu-xenial:/etc/pki/demoCA$ cat index.txt
>
> V  180824075225Z    01  unknown  /C=CN/ST=GD/O=youtiao/OU=dev/CN=luhaozhao/emailAddress=hzlu2010@gmail.com

```bash
openssl x509 -in httpd.crt -noout -serial -subject
sudo openssl ca -revoke ./CA/certs/httpd.crt
```

revoke 后 index.txt

> R  180824075225Z  170824080136Z  01  unknown  /C=CN/ST=GD/O=youtiao/OU=dev/CN=luhaozhao/emailAddress=hzlu2010@gmail.com

```bash
echo 序列号 > /etc/pki/CA/crlnumber # 生成证书吊销列表
openssl ca -gencrl -out ./certs/httpd.crt # 更新证书吊销列表
```

