---
title: APUE 文件和目录
tags:
  - unix
categories:
  - unix
date: 2017-09-22 15:11:19
---


## stat fstat lstat 函数


```c
#include <sys/stat.h>

int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
```

- lstat 返回符号链接的有关信息，而不是由符号链接引用的文件的信息
- 指针 buf 指向一个我们提供的结构

```c
struct stat {
  mode_t st_mode; /* 文件类型 & 权限位 */
  ino_t st_ino; /* i节点编号 */
  dev_t st_dev; /* 设备号（文件系统） */
  dev_t st_rdev; /* 特殊文件设备号，XSI扩展 */
  nlink_t st_nlink; /* 链接数 */
  uid_t st_uid; /* 文件所有者用户ID */
  gid_t st_gid; /* 文件所有者组ID */
  off_t st_size; /* 普通文件字节大小 */
  time_t st_atime; /* 最后访问时间 */
  time_t st_mtime; /* 文件内容最后修改时间 */
  time_t st_ctime; /* 文件属性最后更改时间 */
  blksize_t st_blksize; /* 最优I/O块大小，XSI扩展 */
  blkcnt_t st_blocks; /* 分配的块数目，XSI扩展 */
};
```

### 文件类型

- 普通文件
  + 文本还是二进制对于Unix内核而言无区别
  + 二进制可执行文件应该遵循一种格式，以使内核能确定程序文本和数据的加载位置
- 目录文件
  + 包含了其他 *文件的名字* 以及指向这些文件有关 *信息的指针*
  + 对目录文件具有 *读权限* 的进程可以读取该目录的内容
  + 只有内核可以直接写目录文件
  + 进程必须使用特定函数才能更改目录
- 块特殊文件 block special file
  + 提供对设备 *带缓冲* 的访问
  + 每次访问以固定长度为单位进行
- 字符特殊文件 character special file
  + 提供对设备 *不带缓冲* 的访问
  + 每次访问长度可变
- FIFO
  + 用于进程间通信
  + 有时也称为 *命名管道* named pipe
- socket
  + 用于进程间网络通信
  + 也可用于一台宿主机上进程间非网络通信
- 符号链接 symbolic link

可用宏去确定文件类型，宏的参数是 `stat.st_mode`


```c
#define S_ISDIR(mode) ((mode) & S_IFMT == S_IFDIR) /* 宏的定义 */
```

- `S_ISREG()`
- `S_ISDIR()`
- `S_ISCHR()` 字符特殊文件
- `S_ISBLK()` 块特殊文件
- `S_ISFIFO()` 管道或FIFO
- `S_ISLNK()` 符号链接
- `S_ISSOCK()` 套接字

## 设置用户ID和设置组ID

- 我们实际上谁
  + 实际用户 ID
  + 实际组 ID
- 用于文件访问权限检查
  + 有效用户 ID
  + 有效组 ID
  + 附加组 ID
- 由exec函数保存
  + 保存的设置用户 ID
  + 保存的设置组 ID
  + 在执行一个程序时包含了有效用户ID 有效组ID的副本

- 进程的有效用户ID通常是实际用户ID
  + 当文件模式 `st_mode` 设置了 *设置用户ID* 或 *设置组ID* 后
  + 可以使得进程的有效用户ID 或 有效组ID 设置为 *文件所有者或所有组* 的ID
  + 这种进程是一个 *设置用户(组)ID程序*
  + 可用常量`S_ISUID` 和 `S_ISGID` 测试设置ID位

### 打开设置用户id位

```bash
# chown u+s foo
```

## 文件访问权限

- `S_IRUSR`
- `S_IWUSR`
- `S_IXUSR`
- `S_IRGRP`
- `S_IWGRP`
- `S_IXGRP`
- `S_IROTH`
- `S_IWOTH`
- `S_IXOTH`

- 对路径中的每个目录都应该具有 *执行权限*
- 目录执行权限位常被称为 *搜索位*
- 对目录的读权限允许获取该目录的文件名列表 与目录执行权限不同，注意区别
- 如果PATH环境变量指定了一个我们不具有执行权限的目录，shell不会在该目录下找到可执行文件
- 删除一个现有的文件，必须对包含该文件的目录具有写权限和执行权限，对文件本身不需要读写权限

### 文件访问权限测试

内核进行的测试是：

- 若进程的有效用户ID是0 则允许访问
- 若进程有效用户ID等于文件所有者ID，若 *所有者* 适当的访问权限(rwx)被设置，允许访问，否则拒绝访问
- 若进程有效组ID或进程附加组ID之一等于文件组ID，若 *组* 适当的访问权限位被设置 ...
- 若其他用户适当的访问权限位被设置 ...

匹配了第二步（有效用户ID），就不会看第三步（有效组ID）

## 新文件和目录的所有权

- 新文件的用户ID设置为进程的有效用户ID
- 新文件的组ID
  + 可以是进程的有效组ID
  + 可以是它所在目录的组ID （继承目录的组ID）

## access 函数

access函数是按 *实际用户ID* 和 *实际组ID* 进行访问权限测试的
测试也分为四步，与上面的有效ID测试差不多，但把有效ID改为实际ID

```c
#include <unistd.h>

int access(const char *pathname, int mode);
/* 测试通过返回0 否则-1 */
```

mode是下面常量的 **位或**

- R_OK
- W_OK
- X_OK
- F_OK 测试文件是否存在

## umask 函数

```c
#include <sys/stat.h>

mode_t umask(mode_t cmask);
/* 返回以前的文件模式创建屏蔽字 */
```

- 文件模式创建屏蔽字
- 屏蔽字与进程相关联，umask函数则可以为进程设置屏蔽字
- 参数 `cmask` 是由那9个常量中若干个 *按位或* 构成的
- 屏蔽字中为1的位，在文件mode中相应位则一定被关闭
- 更改进程的文件模式创建屏蔽字并 *不影响* 父进程的屏蔽字


```bash
$ umask -S # 以符号形式打印屏蔽字
```

## chmod fchmod 函数

更改现有文件的访问权限


```c
#include <sys/stat.h>

int chmod(const char *pathname, mode_t mode);
int fchmod(int filedes, mode_t mode);
/* 成功返回0 否则-1 */
```

- 新创建文件的组ID 可能不是调用进程所属的组，新文件的组ID可能是父目录的组ID
- 如果新文件的组ID不等于进程的有效组ID或进程附加组ID中的一个，以及进程没有超级用户权限，那么 **设置组ID位将自动关闭**
- 防止用户创建一个设置组ID文件
- 只有超级用户才能设置普通文件的粘滞位

### 改变文件的权限位要求

- 进程有效用户ID 等于 文件所有者ID
- 或者进程具有超级用户权限

### 参数mode

mode 由下面常量按位或组成

+ S_ISUID 执行时设置用户ID
+ S_ISGID 执行时设置组ID
+ S_ISVTX 保存正文常量 *粘滞位*
+ S_IRWXU 组合常量
  - S_IRUSR
  - S_IWUSR
  - S_IXUSR
+ S_IRWXG 组合常量
  - S_IRGRP
  - S_IWGRP
  - S_IXGRP
+ S_IRWXO 组合常量
  - S_IROTH
  - S_IWOTH
  - S_IXOTH

## 粘滞位 S_ISVTX

sticky bit

早期粘滞位作用

- 早期的Unix系统未使用分页技术，设置了粘滞位的可执行程序正文部分（机器指令部分）会保存副本在交换区（使得下次执行程序能更快装入内存区）
- 交换区占用连续磁盘空间，可视为连续文件（一般文件的数据块可能是随机存放的，不是连续文件）
- 系统再次自举前，文件的正文部分总是在交换区中，所以使用了名字 *粘住* 后来称为 *保存正文位*
- 现在的Unix系统都有配置 **虚拟存储系统** 以及 **快速文件系统** 所以不再需要这种技术

现在粘滞位的使用

对目录设置粘滞位，可以保护目录下的文件不会轻易被删除或改名，需要满足以下条件才能删改：

+ 对目录具有写权限
+ 三选一
  - 拥有此文件
  - 拥有此目录
  - 是超级用户

实际应用是 `/tmp` 目录的权限


```bash
# 设置粘滞位
chmod +t /foo
chmod 1777 /foo
# 清除粘滞位
chmod -t /foo
chmod 0777 /foo
```

## chmod fchown lchown函数

更改文件的用户ID和组ID

```c
#include <unistd.h>

int chown(const char *pathname, uid_t owner, gid_t group);
int fchown(int filedes, uid_t owner, gid_t group);
int lchown(const char *pathname, uid_t owner, gid_t group);
/* 成功返回0 否则返回-1 */
```

- 若参数 `owner` 或 `group` 任意一个是 *-1* 则对应的ID **不变**

若 `_POSIX_CHOWN_RESTRICTED` 对指定的文件起作用

+ 只有超级用户进程能更改文件的用户ID
+ 满足以下条件，一个非超级用户进程可以更改该文件的 **组ID**
  - 进程拥有此文件（有效用户ID等于文件用户ID）
  - 参数owner等于-1 或文件的用户ID ，并且参数 group 等于进程的有效组ID或附加组ID之一

以上意味着当`_POSIX_CHOWN_RESTRICTED`起作用时，

- 不能更改其他用户文件的用户ID
- 可以更改你拥有的文件的组ID，但只能改到你所属的组

### 非超级用户调用，设置位会被清除

如果函数由 *非超级用户* 调用，则在成功返回时，该文件的 *设置用户ID位* 和 *设置组ID位* 会被清除

## 文件长度

- stat 结构成员 st_size表示
- 以字节为单位的文件长度
- 读文件长度为0时，将得到 end-of-file 指示
- 此字段只对普通文件、目录文件和符号链接有意义
- 符号链接文件长度是文件名中的实际字节数
- st_blksize 是对文件I/O较合适的块长度
- st_blocks 是分配的实际512字节块数量 (不同Unix版本其st_blocks所用单位可能不是512字节)

### 文件空洞

- 空洞是由所设置的偏移量超过文件尾端，并写了某些数据后造成的
- 空洞影响文件大小，但不占用磁盘空间

## 文件截短

```c
#include <unistd.h>

int truncate(const char *pathname, off_t length);
int ftruncate(int filedes, off_t length);
```

- 这两个函数将把现有文件的长度截短为length字节，超过部分不再能访问。
- 如果length大于以前的长度，遵循XSI的系统可以增加文件长度，填入空洞。

## 文件系统

- 一个磁盘分成一个或多个**分区**
- 每个分区包含一个**文件系统**
- 文件系统里有多个柱面组
- 每个柱面组里有 *i节点部分* 和 *数据块部分* *目录块部分*
- 目录项指向i节点项
- 节点项指向数据块
- 每个i节点都有 *链接计数* （指向该i节点的目录项数）
- 链接计数包含在 `st_nlink` 成员中，类型为 `nlink_t` 这种链接类型为 *硬链接*
- 符号链接文件的i节点中的文件类型是 `S_IFLNK` 文件实际内容包含了指向的文件的名字
- i节点包含的信息
  + 文件类型
  + 文件访问权限位
  + 文件长度
  + 指向文件所占用的数据块指针
  + 但 **文件名** 是存放在目录项中的
  + **i节点编号** 是存放在目录项中的
- i节点编号的数据类型是 `ino_t`
- 每个文件系统对它们的i节点进行编号，因此不能使一个目录项指向另一个文件系统的i节点
- 因此硬链接不能跨文件系统
- 在同一文件系统下为文件改名的步骤
  + 构建一个指向现有i节点的新目录项
  + 解除旧目录项的链接
  + 这就是mv命令的通常操作

### 普通文件的链接计数

目录块.目录项.i节点号 -> i节点.数据块指针(可能有多个指针) -> 文件内容数据块(可能有多个数据块)

### 目录的链接计数

目录块.目录项(.或..或其它目录文件).i节点号 -> i节点.数据块指针 -> 目录块

- 任何一个叶目录的链接计数总是2
- 父目录中的每一个子目录会使该父目录的链接计数增加1

## link unlink remove rename函数

### link

```c
#include <unistd.h>
int link(const char *existingpaht, const char *newpath);
/* 成功返回0 否则-1 */
```

- 创建一个指向现有文件的链接
- 很多文件系统不允许对目录硬链接
- 如果文件系统允许创建目录硬链接，也仅限于超级管理员

### unlink

```c
#include <unistd.h>
int unlink(const char *pathname);
/* 成功返回0 否则-1 */
```

- 函数用于删除目录项，并将文件的链接计数减1
- 解除链接需要对包含该目录项的**目录**有 *写* 和 *执行* 的权限
- 还要看目录是否设置了粘滞位
  + 设置了粘滞位则需要满足以下条件之一才能解除链接
  + 拥有该文件
  + 拥有该目录
  + 具有超级用户权限
- 只有当链接计数达到0，文件内容才会被删除
- 另外如果有进程打开了该文件，内容也不能删除
- 关闭一个文件时，**内核**先检查打开该文件的进程，再检查链接数，最后才决定删除
- 这种性质经常被程序用来确保及时在程序崩溃时，程序创建的临时文件也不会遗留下来
  + 进程用open或creat创建一个文件
  + 然后立即调用unlink
  + 当进程关闭该文件或终止时，文件内容会被删除

### remove

```c
#include <stdio.h>
int remove(const char *pathname);
/* 成功返回0 否则-1 */
```

- 对于文件 remove 相当于 unlink
- 对于目录 remove相当于 rmdir
- ISO C指定remove函数删除一个文件，原因是实现C标准的大多数非UNIX系统不支持文件链接

### rename

```c
#include <stdio.h>
int rename(const char *oldname, const char *newname);
/* 成功返回0 否则-1 */
```

- 如果引用符号链接，则处理的是符号链接本身
- 如果两个参数引用同一个文件，则函数不做任何更改而成功返回
- 可以对目录改名，newname如果存在则应该是空目录，newname不能包含oldname作为起路径前缀
- 如果newname是一个存在的文件，则会删除newname目录项，然后再更名

## 符号链接

- 任何用户都可创建指向目录的符号链接
- 没有文件系统的限制
- 要留意某些函数是否跟随符号链接
- unlink 函数不跟随符号链接
- 在一个目录中创建一个符号链接 指向父目录 会构成循环链接
- 这种循环可以用unlink消除，但如果是硬链接就很难消除，因此不允许构造指向目录的硬链接
- `ls -F` 会在符号链接的文件名后面加一个 `@` 符号

## symlink 和 readlink函数

```c
#include <unistd.h>
int symlink(const char *actualpath, const char *sympath);
/* 成功返回0 否则-1 */
```

- symlink函数创建一个符号链接
- 不要求actualpath已经存在
- actualpath 和 sympath 并不需要位于同一文件系统中
- open 函数跟随符号链接，readlink函数打开符号链接本身

```c
#include <unistd.h>
ssize_t readlink(const char* restrict pathname, char *restrict buf, size_t bufsize);
/* 成功返回读到的字节数 否则-1 */
```

## 文件的时间

- st_atime 文件数据最后访问时间
- st_mtime 文件数据最后修改时间 *修改时间*
- st_ctime i节点状态的最后修改时间 *状态时间*
- 系统不会保存i节点的最后一次访问时间 所以access 和stat函数不更改这些时间
- ls命令的时间选项
  + `-t` 默认按修改时间先后排序
  + `-u` 按访问时间排序
  + `-c` 按状态更改时间排序

## utime 函数

utime函数用来更改一个文件的访问时间和修改时间

```c
#include <utime.h>
int utime(const char *pathname, const struct utimbuf *times);
/* 成功返回0 否则-1 */
```

```c
struct utimbuf {
  time_t actime; /* access time 访问时间 */
  time_t modtime; /* modification time 修改时间 */
};
```

- 权限要求：进程的有效用户ID必须等于文件的所有者ID 或超级用户进程
- 如果times指针是一个空指针 则两个时间都设置为当前时间
- 当调用utime函数时，文件的状态修改时间会自动更新

