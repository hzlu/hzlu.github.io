---
title: APUE 文件和目录
tags:
  - unix
categories:
  - unix
date: 2017-09-22 15:11:19
---


## stat fstat lstat 函数


```c
#include <sys/stat.h>

int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
```

- lstat 返回符号链接的有关信息，而不是由符号链接引用的文件的信息
- 指针 buf 指向一个我们提供的结构

```c
struct stat {
  mode_t st_mode; /* 文件类型 & 权限位 */
  ino_t st_ino; /* i节点编号 */
  dev_t st_dev; /* 设备号（文件系统） */
  dev_t st_rdev; /* 特殊文件设备号，XSI扩展 */
  nlink_t st_nlink; /* 链接数 */
  uid_t st_uid; /* 文件所有者用户ID */
  gid_t st_gid; /* 文件所有者组ID */
  off_t st_size; /* 普通文件字节大小 */
  time_t st_atime; /* 最后访问时间 */
  time_t st_mtime; /* 文件内容最后修改时间 */
  time_t st_ctime; /* 文件属性最后更改时间 */
  blksize_t st_blksize; /* 最优I/O块大小，XSI扩展 */
  blkcnt_t st_blocks; /* 分配的块数目，XSI扩展 */
};
```

### 文件类型

- 普通文件
  + 文本还是二进制对于Unix内核而言无区别
  + 二进制可执行文件应该遵循一种格式，以使内核能确定程序文本和数据的加载位置
- 目录文件
  + 包含了其他 *文件的名字* 以及指向这些文件有关 *信息的指针*
  + 对目录文件具有 *读权限* 的进程可以读取该目录的内容
  + 只有内核可以直接写目录文件
  + 进程必须使用特定函数才能更改目录
- 块特殊文件 block special file
  + 提供对设备 *带缓冲* 的访问
  + 每次访问以固定长度为单位进行
- 字符特殊文件 character special file
  + 提供对设备 *不带缓冲* 的访问
  + 每次访问长度可变
- FIFO
  + 用于进程间通信
  + 有时也称为 *命名管道* named pipe
- socket
  + 用于进程间网络通信
  + 也可用于一台宿主机上进程间非网络通信
- 符号链接 symbolic link

可用宏去确定文件类型，宏的参数是 `stat.st_mode`


```c
#define S_ISDIR(mode) ((mode) & S_IFMT == S_IFDIR) /* 宏的定义 */
```

- `S_ISREG()`
- `S_ISDIR()`
- `S_ISCHR()` 字符特殊文件
- `S_ISBLK()` 块特殊文件
- `S_ISFIFO()` 管道或FIFO
- `S_ISLNK()` 符号链接
- `S_ISSOCK()` 套接字

## 设置用户ID和设置组ID

- 我们实际上谁
  + 实际用户 ID
  + 实际组 ID
- 用于文件访问权限检查
  + 有效用户 ID
  + 有效组 ID
  + 附加组 ID
- 由exec函数保存
  + 保存的设置用户 ID
  + 保存的设置组 ID
  + 在执行一个程序时包含了有效用户ID 有效组ID的副本

- 进程的有效用户ID通常是实际用户ID
  + 当文件模式 `st_mode` 设置了 *设置用户ID* 或 *设置组ID* 后
  + 可以使得进程的有效用户ID 或 有效组ID 设置为 *文件所有者或所有组* 的ID
  + 这种进程是一个 *设置用户(组)ID程序*
  + 可用常量`S_ISUID` 和 `S_ISGID` 测试设置ID位

### 打开设置用户id位

```bash
# chown u+s foo
```

## 文件访问权限

- `S_IRUSR`
- `S_IWUSR`
- `S_IXUSR`
- `S_IRGRP`
- `S_IWGRP`
- `S_IXGRP`
- `S_IROTH`
- `S_IWOTH`
- `S_IXOTH`

- 对路径中的每个目录都应该具有 *执行权限*
- 目录执行权限位常被称为 *搜索位*
- 对目录的读权限允许获取该目录的文件名列表 与目录执行权限不同，注意区别
- 如果PATH环境变量指定了一个我们不具有执行权限的目录，shell不会在该目录下找到可执行文件
- 删除一个现有的文件，必须对包含该文件的目录具有写权限和执行权限，对文件本身不需要读写权限

### 文件访问权限测试

内核进行的测试是：

- 若进程的有效用户ID是0 则允许访问
- 若进程有效用户ID等于文件所有者ID，若 *所有者* 适当的访问权限(rwx)被设置，允许访问，否则拒绝访问
- 若进程有效组ID或进程附加组ID之一等于文件组ID，若 *组* 适当的访问权限位被设置 ...
- 若其他用户适当的访问权限位被设置 ...

匹配了第二步（有效用户ID），就不会看第三步（有效组ID）

## 新文件和目录的所有权

- 新文件的用户ID设置为进程的有效用户ID
- 新文件的组ID
  + 可以是进程的有效组ID
  + 可以是它所在目录的组ID （继承目录的组ID）

## access 函数

access函数是按 *实际用户ID* 和 *实际组ID* 进行访问权限测试的
测试也分为四步，与上面的有效ID测试差不多，但把有效ID改为实际ID

```c
#include <unistd.h>

int access(const char *pathname, int mode);
/* 测试通过返回0 否则-1 */
```

mode是下面常量的 **位或**

- R_OK
- W_OK
- X_OK
- F_OK 测试文件是否存在

## umask 函数

```c
#include <sys/stat.h>

mode_t umask(mode_t cmask);
/* 返回以前的文件模式创建屏蔽字 */
```

- 文件模式创建屏蔽字
- 屏蔽字与进程相关联，umask函数则可以为进程设置屏蔽字
- 参数 `cmask` 是由那9个常量中若干个 *按位或* 构成的
- 屏蔽字中为1的位，在文件mode中相应位则一定被关闭
- 更改进程的文件模式创建屏蔽字并 *不影响* 父进程的屏蔽字


```bash
$ umask -S # 以符号形式打印屏蔽字
```

## chmod fchmod 函数

更改现有文件的访问权限


```c
#include <sys/stat.h>

int chmod(const char *pathname, mode_t mode);
int fchmod(int filedes, mode_t mode);
/* 成功返回0 否则-1 */
```

- 新创建文件的组ID 可能不是调用进程所属的组，新文件的组ID可能是父目录的组ID
- 如果新文件的组ID不等于进程的有效组ID或进程附加组ID中的一个，以及进程没有超级用户权限，那么 **设置组ID位将自动关闭**
- 防止用户创建一个设置组ID文件
- 只有超级用户才能设置普通文件的粘滞位

### 改变文件的权限位要求

- 进程有效用户ID 等于 文件所有者ID
- 或者进程具有超级用户权限

### 参数mode

mode 由下面常量按位或组成

+ S_ISUID 执行时设置用户ID
+ S_ISGID 执行时设置组ID
+ S_ISVTX 保存正文常量 *粘滞位*
+ S_IRWXU 组合常量
  - S_IRUSR
  - S_IWUSR
  - S_IXUSR
+ S_IRWXG 组合常量
  - S_IRGRP
  - S_IWGRP
  - S_IXGRP
+ S_IRWXO 组合常量
  - S_IROTH
  - S_IWOTH
  - S_IXOTH

## 粘滞位 S_ISVTX

sticky bit

早期粘滞位作用

- 早期的Unix系统未使用分页技术，设置了粘滞位的可执行程序正文部分（机器指令部分）会保存副本在交换区（使得下次执行程序能更快装入内存区）
- 交换区占用连续磁盘空间，可视为连续文件（一般文件的数据块可能是随机存放的，不是连续文件）
- 系统再次自举前，文件的正文部分总是在交换区中，所以使用了名字 *粘住* 后来称为 *保存正文位*
- 现在的Unix系统都有配置 **虚拟存储系统** 以及 **快速文件系统** 所以不再需要这种技术

现在粘滞位的使用

对目录设置粘滞位，可以保护目录下的文件不会轻易被删除或改名，需要满足以下条件才能删改：

+ 对目录具有写权限
+ 三选一
  - 拥有此文件
  - 拥有此目录
  - 是超级用户

实际应用是 `/tmp` 目录的权限


```bash
# 设置粘滞位
chmod +t /foo
chmod 1777 /foo
# 清除粘滞位
chmod -t /foo
chmod 0777 /foo
```

## chmod fchown lchown函数

更改文件的用户ID和组ID

```c
#include <unistd.h>

int chown(const char *pathname, uid_t owner, gid_t group);
int fchown(int filedes, uid_t owner, gid_t group);
int lchown(const char *pathname, uid_t owner, gid_t group);
/* 成功返回0 否则返回-1 */
```

- 若参数 `owner` 或 `group` 任意一个是 *-1* 则对应的ID **不变**

若 `_POSIX_CHOWN_RESTRICTED` 对指定的文件起作用

+ 只有超级用户进程能更改文件的用户ID
+ 满足以下条件，一个非超级用户进程可以更改该文件的 **组ID**
  - 进程拥有此文件（有效用户ID等于文件用户ID）
  - 参数owner等于-1 或文件的用户ID ，并且参数 group 等于进程的有效组ID或附加组ID之一

以上意味着当`_POSIX_CHOWN_RESTRICTED`起作用时，

- 不能更改其他用户文件的用户ID
- 可以更改你拥有的文件的组ID，但只能改到你所属的组

### 非超级用户调用，设置位会被清除

如果函数由 *非超级用户* 调用，则在成功返回时，该文件的 *设置用户ID位* 和 *设置组ID位* 会被清除

## 文件长度

- stat 结构成员 st_size表示
- 以字节为单位的文件长度
- 读文件长度为0时，将得到 end-of-file 指示
- 此字段只对普通文件、目录文件和符号链接有意义
- 符号链接文件长度是文件名中的实际字节数
- st_blksize 是对文件I/O较合适的块长度
- st_blocks 是分配的实际512字节块数量 (不同Unix版本其st_blocks所用单位可能不是512字节)

### 文件空洞

- 空洞是由所设置的偏移量超过文件尾端，并写了某些数据后造成的
- 空洞影响文件大小，但不占用磁盘空间

## 文件截短

```c
#include <unistd.h>

int truncate(const char *pathname, off_t length);
int ftruncate(int filedes, off_t length);
```

- 这两个函数将把现有文件的长度截短为length字节，超过部分不再能访问。
- 如果length大于以前的长度，遵循XSI的系统可以增加文件长度，填入空洞。

