---
title: APUE 基础知识
tags:
  - unix
categories:
  - unix
date: 2017-09-20 14:53:58
---


## UNIX 体系结构

- 硬件资源
- 内核
- 系统调用 **内核的接口**
- 公用函数库 构建在系统调用接口之上
- shell 一种特殊的应用程序，为其他应用程序提供一个接口
- 应用程序 可使用公用函数库，也可使用系统调用

## shell

常见shell

- `/bin/sh`
- `/bin/bash`
- `/bin/csh`
- `/bin/ksh`
- `/bin/tcsh`

系统从口令文件 `/etc/passwd` 对应用户最后一个字段了解到应该执行哪个shell

### **交互式shell** versus **非交互式shell**

- 交互模式 就是在终端上执行，等待你的输入，并且立即执行你提交的命令
- 非交互模式 以shell script 方式执行

```bash
echo $- # 打印当前shell的选项标志 i 即表示 interactive shell
```

### 登录shell VS 非登录shell

- 登录shell 需要用户名、密码登录后才能进入的shell 或通过 `bash --login` 生成的shell
  + `echo $0` 进程名是 `-bash`
  + 读取配置 `/etc/profile` > (`~/.bash_profile` || `~/.bash_login` || `~/.profile`)
- 非登录shell 打开终端窗口程序是一个非登录shell, 直接使用命令 `bash` 打开一个 非登录shell
  + `echo $0` 进程名是 `bash`
  + 读取配置 `~/.bashrc`

退出登出

- exit 退出一个shell 登录shell 或 非登录shell
- logout 登出登录shell 不能退出非登录shell

## 文件和目录

- 文件名不能出现斜线 `/` 和 空操作符 `null`
- 目录是一个包含许多目录项的文件
- 创建新目录时自动创建两个文件名 `.` 和 `..` 点指向当前目录，点点指向父目录
- 根目录点和点点相同
- 每个进程都有一个当前工作目录 `cwd` 所有**相对路径名**都从 `cwd` 开始解释
- 进程可以用 `chdir` 函数更改 `cwd`
- 起始目录 `home directory` 从口令文件中得到 登录时 `cwd` 会设置为起始目录

## 输入和输出

- 文件描述符，当内核打开一个已有文件或创建一个新文件时返回一个 `file descriptor`
- 每运行一个新程序，所有shell都为它打开三个文件描述符 `STDIN_FILENO` `STDOUT_FILENO` `STDERR_FILENO`
- 不做重定向处理，默认三个文件描述符都链向终端

### 不带缓冲的 I/O

- open
- read
- write
- lseek
- close

以上函数都使用文件描述符，**不带缓冲**

### 标准 I/O

**标准I/O函数** 提供了一种对 **不带缓冲I/O函数** 的带缓冲的接口

`<stdio.h>` 包含了所有标准I/O函数的原型

优点：

- 无需担心如何选取最优的缓冲区大小
- 简化对输入行的处理，直接读取一整行而不像 `read` 指定字节数

## 程序和进程

- 程序，是存放在磁盘上、处于某个目录中的一个**可执行文件**
- 通过exec函数，由内核读入存储器，并执行
- 进程，程序的执行实例
- 每个进程都有一个唯一的进程ID

### 进程控制

- fork 创建一个新进程，它由父进程调用一次，但返回两次（分别在父进程和子进程中）
- execlp 执行从标准输入读入的命令，用新的程序文件 **替换** 了原先执行的程序文件
- fork + exec 的组合是某些操作系统所称的 **spawn** 一个新进程，在UNIX 中这两部分相互分隔，构成两个函数
- waitpid 等待子进程终止，返回终止状态

### 线程和线程ID

- 同一进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性
- 线程ID只在它所属的进程内起作用
- 线程模型在进程模型建立很久后才被引入到UNIX

## 出错处理

- errno 通常被设置为含有附加信息的一个值，指示出错原因
- 某些函数不返回负值，而是使用另一个约定，返回Null指针
- 如果没有出错，errno的值也不会被清除，因此应在函数返回指名出错时才去验证它的值
- 任何函数都不会将errno的值设置为0，在头文件中定义的所有常量都不为0

头文件 `<errno.h>` 定义了符号errno以及可以赋予它的各种常量，常量以 `E` 开头。

```c
#include <string.h>

char *strerror(int errnum);
/* 将errnum 通常是errno值 映射为一个出错信息字符串，并返回此字符串的指针 */

#include <stdio.h>

void perror(const char *msg);
/* 基于errno的当前值在标准出错上产生一条出错信息 */
```

## 用户标识

- 用户ID
- 组ID
- 每个文件都存放所有者的用户ID和组ID
- 存放数值比存放字符串节省空间
- 附加组ID 一个用户可属于多至16个附加组

## 信号

进程处理信号的三种选择

- 忽略该信号
- 按系统默认方式处理
- 提供一个函数，捕捉该信号，signal函数


```c
signal(SIGINT, sig_int);
/* 注册函数 */
```

产生信号

- 终端键盘上的中断键 Delete键或Ctrl+C
- 终端键盘上的退出键 Ctrl+\
- kill函数发送信号
- kill限制：必须是该进程的所有者或超级用户

## 时间值

- 日历时间 时间戳
  + 系统基本数据类型 `time_t` 保存这种时间值
- 进程时间 也称为CPU时间
  + 用以度量进程使用CPU资源，以时钟滴答计数
  + 系统基本数据类型 `clock_t` 保存这种时间值
  + 函数 `sysconf` 得到每秒时钟滴答数

度量一个进程的执行时间

- 时钟时间 又称为 **墙上时钟时间** 进程运行的时间总量，其值与系统中同时运行的进程数有关
- 用户CPU时间，执行用户指令所用时间
- 系统CPU时间，为该进程执行内核程序所经历的时间
- CPU时间 = 用户CPU时间 + 系统CPU时间

## 系统调用和库函数

- 从实现者角度，系统调用和库函数之间有重大区别
- 从用户角度看，区别并不重要
- 系统调用和库函数都以C函数的形式出现，两者都为应用程序提供服务
- 系统调用提供一种最小接口
- 库函数通常提供比较复杂的功能
- 系统调用指最底层的一个调用，面向硬件；库函数调用面向应用开发
- 系统调用是操作系统相关的，一般没有跨平台的可移植性
- 应用程序可以调用系统调用或库函数，而很多库函数则会调用系统调用

