---
title: APUE 文件I/O
tags:
  - unix
categories:
  - unix
date: 2017-09-21 16:31:04
---



## 基础概念

- 不带缓冲的I/O unbuffered I/O
- 术语不带缓冲指的是每个read 和 write 都调用内核中的一个系统调用
- 文件描述符，内核向进程返回
- open create 返回文件描述符
- read write 用文件描述符作为参数
- 0 1 2 应该分别由符号常量 STDIN_FILENO STDOUT_FILENO STDERR_FILENO 替换
- 这些符号常量定义在头文件 `<unistd.h>` 中
- 文件描述符的变化范围是 0 ~ OPEN_MAX

## open 函数


```c
#include <fcntl.h>

int open(const char *pathname, int oflag, ... /* mode_t mode */);
/* 成功返回文件描述符，失败返回 -1 */
```

`oflag` 说明函数的选项，用下列常量进行 **或** 运算构成

- O_RDONLY 只读打开
- O_WRONLY 只写打开
- O_RDWR   读、写打开

常量定义在头文件 `<fcntl.h>` 中

其余可选的选项常量

- O_APPEND 写追加文件尾
- O_CREAT 若文件不存在则创建，需要指定新文件访问权限位的第三个参数 mode
- O_EXCL 如果同时指定 O_CREAT 而文件又存在时，就会出错。使得测试和创建两者成为一个原子操作
- O_TRUNC 如文件存在，且为只写或读写，则长度截短为0
- O_NOCTTY 如果路径是终端设备，则不将该设备分配为进程的控制终端
- O_NONBLOCK 如果路径是 FIFO 块特殊文件 字符特殊文件 则设置为非阻塞模式
- O_DSYNC 使每次write等待物理操作完成，可以不等待文件属性更新
- O_RSYNC 使read操作等待，等待写操作完成才进行read
- O_SYNC 使每次write都等待物理I/O完成，包括文件属性的更新

## creat 函数

```c
#include <fcntl.h>

int creat(const char *pathname, mode_t mode);
/* 相当于调用 */
open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);
```

早起UNIX无法打开一个尚未存在的文件，因此需要系统调用 creat，现在open函数提供了新选项，也就不再需要creat

## close 函数

```c
#include <unistd.h>

int close(int filedes);
/* 关闭成功返回0 否则返回 -1 */
```

当进程终止时，内核会自动关闭进程打开的所有文件，因此可以不显式调用close关闭打开文件

## lseek 函数

- 与文件有一个关联的 **当前文件偏移量**
- 除非指定 O_APPEND 选项，否则打开文件时偏移量设置为0
- 调用 lseek 显示设置偏移量
- 偏移量大于文件当前长度，下一次写操作将加长该文件，中间构成空洞
- 文件空洞不占用磁盘空间，空洞会被读为0
- 使用 od 命令可以看到文件的实际内容
- 最大文件偏移量根据 off_t 数据类型长度决定，不同实现长度不同
- 偏移量仅仅记录在内核中，不引起任何I/O操作
- **只修改文件表项中的当前文件偏移量，没进行I/O操作**

```c
#include <unistd.h>

off_t lseek(int filedes, off_t offset, int whence);
/* 返回新的偏移量或 -1 */
```

whence 的取值

- SEEK_SET 距文件开始处 offset 个字节
- SEEK_CUR 设置为当前值加offset 可正可负
- SEEK_END 设置为文件长度加offet 可正可负


```c
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);
/* 确定打开文件的当前偏移量 */
```

### 不能对管道、FIFO或套接字 设置偏移量

## read 函数

```c
#include <unistd.h>
ssize_t read(int filedes, void *buf, size_t nbytes);
/* 返回读到的字节数 或到文件尾返回0 或出错返回-1 */
```

- `void *` 用于表示通用指针
- `ssize_t` 是一个带符号整数
- `size_t` 第三个参数是不带符号整数

## write 函数

```c
#include <unistd.h>
ssize_t read(int filedes, const void *buf, size_t nbytes);
/* 返回已写的字节数 或出错返回-1 */
```

返回值通常与参数nbytes相同，否则表示出错
写出错的原因：

- 磁盘写满
- 超过一个给定进程的文件长度限制

## I/O的效率

BUFFsize 设置为文件系统块长度时性能最好，块长由 `st_blksize` 表示。

大多数文件系统为改善性能都采用预读 **read ahead** 技术。当检测到正进行顺序读取时，
系统企图读入比应用程序所要求的更多数据，并假想应用程序很快就会读这些数据。

## 文件共享

- UNIX 支持不同进程之间共享打开的文件。
- 内核使用三种数据结构表示打开的文件。
- 打开文件描述符表
  + 每个进程在进程表中有一个记录项，记录项包含了这张文件描述符表
  + 也可存放在用户空间，而非进程表中
  + 描述符表项包含：
  + a) 文件描述符标志
  + b) 指向文件表项的指针
- 文件表
  + 内核为所有**打开文件**维持一张文件表
  + 每个进程都有自己的文件表项，使得进程有自己对文件的当前偏移量
  + 文件表项包含：
  + a) 文件状态标志
  + b) 当前文件偏移量
  + c) 指向 **文件v节点表** 的指针
- v节点结构
  + Linux 没有使用v节点，而是使用通用i节点结构
  + 每个打开的文件或设备都有一个v节点结构
  + 一个给定的文件只有一个v节点表项
  + v节点包含：
  + 1) 文件类型
  + 2) 对此文件进行操作的函数的指针
  + 3) i节点 i-node 索引节点 （文件所有者 文件长度 文件所在设备 指向文件实际数据块在磁盘上所在位置的指针等）

- 如果使用O_APPEND 标志打开一个文件，则相应标志也被设置到 *文件表项* 的 *文件状态标志* 中。
- **每次** 对具有添写标志的文件执行写操作时，当前文件偏移量首先被设置为 *i节点* 表项中的文件长度。
- **每次写都会设置偏移量**
- 可能有多个文件描述符项指向同一个文件表项
- 当多个进程同写一个文件时，可能会产生预期不到的结果，需要原子操作避免

## 原子操作

- 任何一个需要多个函数调用的操作都不可能是原子操作，在函数调用之间，内核可能会临时挂起进程
- 设置O_APPEND 标志可以保证每次写之前都会设置偏移量到文件尾端
- 对open 函数使用 O_CREAT 和 O_EXCL 选项能保证原子操作
- pread函数 和 pwrite函数 是原子操作 (属于 XSI 扩展)


```c
#include <unistd.h>

ssize_t pread(int filedes, void *buf, size_t nbytes, off_t offset);
/* 相当于原子顺序调用 lseek 和 read */

ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);
/* 相当于原子顺序调用 lseek 和 write */
```

## dup函数和dup2函数

用于复制文件描述符

```c
#include <unistd.h>

int dup(int filedes);
/* 返回可用描述符 */

int dup2(int filedes, int filedes2);
/* 指定新描述符数值 filedes2 */
```

- 如果filedes2已经打开，先将其关闭
- 如果filedes 等于 filedes2，则不关闭filedes2 而直接返回 filedes2
- 这些函数返回的新描述符与参数 filedes *共享* 同一个文件表项
- 新描述符的执行时关闭 `close-on-exec` 标志会由dup函数清除（标志被清除表示 该描述符在经过一个exec时仍保持有效）
- 复制一个描述符的另一方法是使用 fcntl 函数

## sync fsync 和 fdatasync 函数

延时写 **delayed write**
输出方式：当数据写入文件时，内核通常先将数据复制到其中一个缓冲区中，
如果该缓冲区未写满，则不会将其排入输出队列，
等待其写满或内核需要重用该缓冲区（以便存放其他磁盘块数据）时，再讲缓冲排入输出队列，
然后等待其到达队首时才进行实际的 I/O 操作。

延迟写减少了磁盘读写次数，但却降低了文件内容的更新速度，
当发生故障时这种延迟写可能造成文件更新内容的丢失，
*为了保证磁盘上实际文件系统与高速缓存中内容的一致性，*
UNIX 系统提供了 sync fsync 和 fdatasync 三个函数。


```c
#include <unistd.h>
int fsync(int filedes);
int fdatasync(int filedes);

void sync(void);
```

- sync函数不等待实际写磁盘操作结束，只将修改过的块缓冲排入写队列
- 命令 sync 也调用sync函数
- 系统守护进程会周期调用 sync函数，保证定期冲洗内核的块缓冲区
- fsync 对指定的描述符起作用，等待写磁盘操作完成，包括数据部分和更新文件属性
- fdatasync 类似fsync 但只影响文件的数据部分

## fcntl 函数

可以改变已打开的文件的性质

```c
#include <fcntl.h>

int fcntl(int fidedes, int cmd, ... /* int arg */);
```
作用：

- 复制一个现有的描述符 cmd=F_DUPFD
- 获得或设置 文件描述符标记 cmd=F_GETFD 或 F_SETFD
- 获得或设置 文件状态标志 cmd=F_GETFL 或 F_SETFL
  + 三个访问方式标志 O_RDONLY O_WRONLY O_RDWR 并不各占1位，因此首先要用屏蔽字 O_ACCMODE 取得访问模式位，然后将结果进行比较
  + 可以设置的几个标志是 O_APPEND O_NONBLOCK O_SYNC O_DSYNC O_RSYNC O_FSYNC O_ASYNC
- 获得或设置 异步I/O所有权 cmd=F_GETOWN 或 F_SETOWN
  + 取得当前接收 SIGIO 和 SIGURG 信号的进程ID或进程组ID
- 获得或设置 记录锁 cmd=F_GETLK F_SETLK 或 F_SETLKW

该函数的返回值与命令有关，如果出错所有命令都返回 -1


```c
#include <fcntl.h>

int
main(int argc, char *argv[])
{
  int   val;
  if (argc != 2)
    err_quit("usage: a.out <descriptor#>");

  if ((val = fcntl(atoi(argv[1]), F_GETFL, 0)) < 0)
    err_sys("fcntl error for fd %d", atoi(argv[1]));

  switch (val & O_ACCMODE) {
  case O_RDONLY:
    printf("read only");
    break;
  case O_WRONLY:
    printf("write only");
    break;
  case O_RDWR:
    printf("read write");
    break;
  default:
    err_dump("unknown access mode");
  }

  if (val & O_APPEND)
    printf(", append");
  if (val & O_NONBLOCK)
    printf(", nonblocking");
  if (val & O_SYNC)
    printf(", synchronous writes");

#if !defined(_POSIX_C_SOURCE) && defined(O_FSYNC) && (O_FSYNC != O_SYNC)
  if (val & O_FSYNC)
    printf(", synchronous writes");
#endif

  putchar('\n');
  exit(0);
}
```

修改文件状态标志时要先取得现有标志值，然后根据需要修改，最后设置新标志值:

```c
#include <fcntl.h>

void
set_fl(int fd, int flags) /* flags are file status flags to turn on */
{
  int   val;

  if ((val = fcntl(fd, F_GETFL, 0)) < 0)
    err_sys("fcntl F_GETFL error");

  val |= flags;   /* turn on flags */

  if (fcntl(fd, F_SETFL, val) < 0)
    err_sys("fcntl F_SETFL error");
}
```

```c
#include <fcntl.h>

void
clr_fl(int fd, int flags) /* flags are file status flags to turn on */
{
  int   val;

  if ((val = fcntl(fd, F_GETFL, 0)) < 0)
    err_sys("fcntl F_GETFL error");

  val &= ~flags;   /* turn off flags */

  if (fcntl(fd, F_SETFL, val) < 0)
    err_sys("fcntl F_SETFL error");
}
```

调用打开 O_SYNC 使得每次write都要等待，直至数据写到磁盘上再返回，数据库系统很可能需要使用O_SYNC

- fsync和fdatasync 在我们需要时更新文件内容
- O_SYNC 标志则在我们每次写至文件时更新文件内容

```c
set_fl(STDOUT_FILENO, O_SYNC);
```

## /dev/fd 目录

打开文件 `/dev/fd/n` 等效于复制描述符n (假定n是打开的)

使用/dev/fd 提高文件名参数的一致性，也更加清晰，无需使用 `-` 这种需要特殊解释的文件名

