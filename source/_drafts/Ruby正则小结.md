---
title: Ruby 正则小结
category: ruby
---

## 语法

~~~ruby
str =~ /regex/
~~~

返回在str中匹配的**子字符串**`索引`，不匹配返回`nil`

## 正则表达式选项：

~~~ruby
/normal regex/iomx[neus]
%r{alternate form}
~~~

- `i` 忽略大小写模式
- `o` 只使用一次内嵌表达式
- `m` 多行匹配模式，点号`.`能匹配换行符`\n`哦
- `x` 忽略正则中的空白字符以及#后面的字符
- `[neus]`

## 匹配结果

- `$1 $2 $3`
- <code>$`</code> 表示匹配部分前的字符串
- `$&` 匹配部分字符串
- `$'` 匹配部分后的字符串

## 正则语法

|代码|说明或示例|
|--|--|
|**元字符**|**=======================================**|
|`.`|匹配除了换行符`\n`以外的任意字符。`"\nhello" =~ /./` 返回1，点号不匹配换行符|
|`\w`|匹配`[0-9a-zA-Z_]`数字字母下划线。`"\nhello" =~ /\w/m` 返回1，不匹配换行符和汉字|
|`\W`|除数字字母下划线外的字符|
|`\s`|匹配任意空白符，`[\t\n\r\f ]`都匹配|
|`\S`|除了空白符都匹配|
|`\d`|匹配数字，`[0-9]`|
|`\D`|匹配非数字|
|`^`|匹配字符串开头|
|`$`|匹配字符串结尾|
|`\b`|在`[]`里匹配退格键，在外面匹配单词边界|
|**限定符**|**=======================================**|
|`*`|重复任意次的**贪婪匹配**|
|`*?`|重复任意次的**懒惰匹配**|
|`+`|重复1次或多次的**贪婪匹配**|
|`+?`|重复1次或多次的**懒惰匹配**|
|`?`|重复0次或1次的**贪婪匹配**|
|`??`|重复0次或1次的**懒惰匹配**|
|`[]`|匹配集合中的一个字符|
|`[^]`|匹配一个非集合字符|
|`{n}`|重复n次`"aa" =~ /[:alpha:]{2}/`|
|`{n,}`|重复n次或更多次`"aa" =~ /[:alpha:]{2,}/`|
|`{n,m}`|重复n到m次|
|**分组捕获**|**=======================================**|
|`(exp)`|匹配exp并捕获文本到自动命名的组里，组号从1开始`$1 $2 ...`|
|`(?<name>exp)`|捕获文本到名为`name`的组里，要不都命名，要不都不要命名，不然拿不到未命名组的文本。|
|`(?:exp)`|匹配，不捕获，也不分配组号|
|**零宽断言**|**=======================================**|
|`(?=exp)` |零宽正预测先行断言，断言此位置的后面能匹配表达式exp|
|`(?<=exp)`|零宽正预测后发断言，断言此位置的前面能匹配表达式exp|
|`(?!exp)` |零宽负预测先行断言，断言此位置的后面不能匹配表达式exp|
|`(?<!exp)`|零宽负预测后发断言，断言此位置的前面不能匹配表达式exp|
|`(?#comment)`|注释|

~~~ruby
"I am reading." =~ /\b\w+(?=ing\b)/
"I am reading." =~ /(?<=\bre)\w+\b/
pattern = /\d{3}(?!\d)(?#匹配三位数字，而且这三位数字的后面不能是数字)/
pattern = /(?<![a-z])\d{7}(?# 匹配前面不是小写字母的七位数字)/
/2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)/
~~~

### 特殊字符集

~~~ruby
[:alpha:]
[:alnum:]
[:cntrl:]
[:graph:]
[:lower:]
[:upper:]
[:blank:] 不包含`\t\r\f`
[:space:]
[:digit:]
[:xdigit:]
[:print:]
[:punct:]
~~~

## `sub` `gsub`方法

~~~ruby
str = "abc123def456g78hi"
# sub只替换首次匹配
p str.sub(/\d/, '')
# gsub则替换所有匹配
p str.gsub(/\d/, '')
~~~

## `match`方法

~~~ruby
m = "hello world <h1>TITLE</h1>\n".match(/<h1>(?<foo>\w+)<\/h1>/)
# => #<MatchData "<h1>TITHEL</h1>" foo:"TITHEL">
m[:foo] == 'TITLE'
~~~

## `scan`方法

~~~ruby
s = "123--abc,123--abc,123--abc"
s.scan(/(\d*)--([a-z]*)/)
# => [["123", "abc"], ["123", "abc"], ["123", "abc"]]
~~~

可以使用`%r()` `%r<>` `%r||` `%r!!`来创建正则表达式。

### 正则表达式 =~ 字符串

### 正则表达式 !~ 字符串

使用 `^$` 分别匹配行首行尾，使用 `\A\z` 分别匹配字符串开头和末尾。

`\Z` 这是一个比较少用的元字符，与`\z`作用相似，但如果字符串末尾是换行符，就回匹配换行符前一个字符。

字符类中要匹配`-`就需要把它写在开头或结尾，如`[a-zA-Z0-9_-]`

`\w` 匹配英文字母和数字下划线

贪婪匹配：`/A.*B/`，默认的匹配方式

懒惰匹配：`/A.*?B/` 添加元字符`?`

转义正则表达式元字符，使用quote方法。`re = Regexp.new(Regexp.quote("abc*def"))`

正则表达式选项

* i Regexp::IGNORECASE ignorecase 忽略大小写
* x extended 忽略空白字符，以及可以在正则表达式中使用#注释
* m multiline 可以使用 `.` 匹配换行符
* o 只使用一次内嵌表达式

`Regexp.new("Ruby脚本", Regexp::IGNORECASE|Regexp::MULTILINE)` 等价于 `/Ruby脚本/im`

##捕获

通过`$1`可以获取匹配了正则表达式中用第一个括号括住的部分字符串

`(?:)`可以过滤掉不需要捕获的模式。

三个变量

* $` 匹配部分前的字符串
* $& 匹配部分的字符串
* $' 匹配部分后的字符串

注意是匹配部分的字符串，不是捕获的字符串。

`sub` 和 `gsub` 方法还可以使用块，会把字符串中匹配的部分（字符串）传递给块去处理，返回的字符串进行替换。

`scan` 方法与`gsub`的匹配行为相似，但不做替换，而是对匹配部分进行处理。如果不带块，就会返回匹配的字符串数组。scan参数的正则中如果使用了`()` 匹配的部分就会以数组的形式返回。
