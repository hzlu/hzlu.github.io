<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>卢浩钊的博客</title>
  
  <subtitle>技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luhaozhao.com/"/>
  <updated>2018-06-27T08:07:17.427Z</updated>
  <id>http://luhaozhao.com/</id>
  
  <author>
    <name>卢浩钊&lt;hzlu2010@gmail.com&gt;</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Tmux</title>
    <link href="http://luhaozhao.com/2017/10/21/tmux-usage/"/>
    <id>http://luhaozhao.com/2017/10/21/tmux-usage/</id>
    <published>2017-10-21T15:06:59.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>终端复用</li><li>session 用来区分不同的工作环境</li><li>window 一个session下能创建多个window</li><li>pane 一个window下可以创建多个视图，切分窗口</li></ul><p>底部状态栏上有tmux的session window 及 pane 信息，右侧有主机、时间日期信息，状态栏可定制。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>命令前缀 <code>Ctrl b</code> 用 <code>C - b</code> 表示</li></ul><h3 id="pane-命令"><a href="#pane-命令" class="headerlink" title="pane 命令"></a>pane 命令</h3><ul><li><code>C - b %</code> 创建垂直分割的pane</li><li><code>C - b &quot;</code> 创建水平分割的pane</li><li><code>C - b o</code> 切换到下一个pane</li><li><code>C - b 方向箭头</code> 切换pane</li><li><code>C - b z</code> 最大化当前pane</li><li><code>C - b x</code> 关闭pane</li></ul><h3 id="window-命令"><a href="#window-命令" class="headerlink" title="window 命令"></a>window 命令</h3><ul><li><code>C - b c</code> 新建window</li><li><code>C - b p</code> 切换到前一个window</li><li><code>C - b n</code> 切换到下一个window</li><li><code>C - b &lt;数字&gt;</code> 选择window 状态栏显示的window序号</li><li><code>tmux rename-window -t &lt;name&gt; &lt;new-name&gt;</code> 重命名window</li><li><code>C - b &amp;</code> 关闭window</li></ul><h3 id="session-命令"><a href="#session-命令" class="headerlink" title="session 命令"></a>session 命令</h3><ul><li><code>C - b d</code> detach session</li><li><code>C - b s</code> session 切换</li><li><code>tmux attach -t &lt;session-name&gt;</code> attach session</li><li><code>tmux rename-session -t &lt;name&gt; &lt;new-name&gt;</code> 重命名session</li><li><code>tmux new-session -s &lt;session-name&gt;</code> 直接创建命名session</li><li><code>tmux new-session -s &lt;session-name&gt; -d</code> 创建detach状态的命名session</li><li><code>tmux new-session -s &lt;session-name&gt; -n &lt;window-name&gt;</code> 创建命名session及命名window</li></ul><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul><li><code>C - b [</code> 进入复制模式 空格开始选择 回车把选择内容复制到剪切板</li><li><code>C - b ]</code> 粘贴</li><li><code>C - b ?</code> 查看帮助</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;终端复用&lt;/li&gt;
&lt;li&gt;session 用来区分不同的工作环境&lt;/li&gt;
&lt;li&gt;window 一个sess
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tmux" scheme="http://luhaozhao.com/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>rails-decorator-pattern</title>
    <link href="http://luhaozhao.com/2017/10/16/rails-decorator-pattern/"/>
    <id>http://luhaozhao.com/2017/10/16/rails-decorator-pattern/</id>
    <published>2017-10-16T17:13:46.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.thegreatcodeadventure.com/rails-refactoring-part-iii-the-decorator-pattern/" target="_blank" rel="external">原文链接</a></p><h2 id="什么是装饰器模式"><a href="#什么是装饰器模式" class="headerlink" title="什么是装饰器模式"></a>什么是装饰器模式</h2><p>装饰器模式允许我们对某个实例对象添加一些行为，但又不影响类的其他实例对象。在把模型实例传给视图前，我们能“装饰”这个模型实例，或者我们可以在视图中装饰这个实例。</p><p>通过抽取复杂的呈现逻辑，可以简化视图层和模型层</p><h2 id="装饰视图"><a href="#装饰视图" class="headerlink" title="装饰视图"></a>装饰视图</h2><ul><li>定义文件夹 <code>app/decorators</code></li><li>定义文件 <code>app/decorators/repository_decorator.rb</code></li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># app/decorators/repository_decorator.rb</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoryDecorator</span> &lt; SimpleDelegator</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">display_name</span></span></div><div class="line">    name.gsub(<span class="string">'-'</span>, <span class="string">' '</span>).titleize</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p><code>SimpleDelegator</code> 是 Ruby 原生类</p><h3 id="装饰前的视图代码"><a href="#装饰前的视图代码" class="headerlink" title="装饰前的视图代码"></a>装饰前的视图代码</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># app/views/repositories/_repo.html.erb</span></div><div class="line">&lt;%= @repository.name.gsub(<span class="string">"-"</span>, <span class="string">" "</span>).titleize %&gt;</div><div class="line"></div><div class="line"><span class="comment"># app/views/issues/show.html.erb</span></div><div class="line">&lt;%= @issue.repository.name.gsub(<span class="string">"-"</span>, <span class="string">" "</span>).titleize %&gt;</div></pre></td></tr></table></figure><h3 id="装饰后的视图代码"><a href="#装饰后的视图代码" class="headerlink" title="装饰后的视图代码"></a>装饰后的视图代码</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># app/views/repositories/_repo.html.erb</span></div><div class="line">&lt;%= RepositoryDecorator.new(@repository).display_name %&gt;</div><div class="line"></div><div class="line"><span class="comment"># app/views/issues/show.html.erb</span></div><div class="line">&lt;%= RepositoryDecorator.new(@issue.repository).display_name %&gt;</div></pre></td></tr></table></figure><h2 id="装饰模型"><a href="#装饰模型" class="headerlink" title="装饰模型"></a>装饰模型</h2><p>假设有这么个模型</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># app/models/user.rb</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_phone_number</span></span></div><div class="line">  phone_number &amp;&amp; !phone_number.empty? ?</div><div class="line">    phone_number : <span class="string">"</span></div><div class="line"><span class="string">     &lt;i&gt;add your phone number to receive text</span></div><div class="line"><span class="string">     message updates&lt;/i&gt;"</span>.html_safe</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>在视图中调用这个方法</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># app/views/users/show.html.erb</span></div><div class="line">...</div><div class="line">&lt;p&gt;phone <span class="symbol">number:</span> &lt;%= @user.display_phone_number %&gt;</div></pre></td></tr></table></figure><p>以上违反了单一职责原则，在模型中写入了表现层的逻辑</p><h3 id="装饰器修改"><a href="#装饰器修改" class="headerlink" title="装饰器修改"></a>装饰器修改</h3><ul><li>创建文件 <code>app/decorators/user_decorator.rb</code></li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># app/decorators/user_decorator.rb</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDecorator</span> &lt; SimpleDelegator</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">display_phone_number</span></span></div><div class="line">    phone_number &amp;&amp; !phone_number.empty? ?</div><div class="line">      phone_number : <span class="string">"</span></div><div class="line"><span class="string">      add your phone number to receive text</span></div><div class="line"><span class="string">       message updates"</span>.html_safe</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>在视图中使用</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># app/views/users/show.html.erb</span></div><div class="line">...</div><div class="line">&lt;p&gt;phone <span class="symbol">number:</span> &lt;%= UserDecorator.new(@user).display_phone_number %&gt;</div></pre></td></tr></table></figure><p>以上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.thegreatcodeadventure.com/rails-refactoring-part-iii-the-decorator-pattern/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="rails" scheme="http://luhaozhao.com/categories/rails/"/>
    
    
      <category term="ruby" scheme="http://luhaozhao.com/tags/ruby/"/>
    
      <category term="rails" scheme="http://luhaozhao.com/tags/rails/"/>
    
      <category term="设计模式" scheme="http://luhaozhao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程环境</title>
    <link href="http://luhaozhao.com/2017/10/11/apue-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/"/>
    <id>http://luhaozhao.com/2017/10/11/apue-进程环境/</id>
    <published>2017-10-11T15:40:12.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<ul><li>进程ID 0 为内核交换进程使用</li><li>init进程进程ID 为1</li><li>init进程的程序文件是 <code>/etc/init</code> 或 <code>/sbin/init</code></li><li>此进程负责在自举后启动一个UNIX系统</li><li>通常会读取与系统有关的初始化文件 <code>/etc/init.d/</code>中的文件 <code>/etc/inittab</code> <code>/etc/rc*</code> 等文件</li><li>将系统引导到一个状态，init进程决不会终止</li><li>它会成为所有孤儿进程的父进程</li><li>fork 之后是父进程先执行还是子进程先执行都是不确定的，取决于内核使用的调度算法</li><li>fork 会复制打开的文件描述符，父子进程的每个相同的文件描述符共享一个文件表项</li><li>fork 之后处理文件描述符有两种常见情况：<ul><li>父进程等待子进程完成。父进程无需对其描述符做任何处理，子进程终止后，共享描述符的文件偏移量都执行了更新</li><li>父子进程各自执行不同的程序段。fork之后各自关闭不需要使用的文件描述符，这样就不会干扰到对方，这是网络服务进程中经常使用的</li></ul></li><li>fork有两种用法：<ul><li>父进程希望复制自己，使父子进程同时执行不同的代码段，常见于网络服务进程</li><li>一个进程要执行一个不同的程序，常见于shell，子进程fork后立即调用exec（fork后执行exec组合成一个称为 spawn）</li></ul></li><li>vfork 和 fork 一样都创建一个子进程，但它不降父进程的地址空间完全复制到子进程中</li><li>因为vfork的子进程会立即调用exec（或 exit）</li><li>vfork保证子进程先运行，在子进程调用后父进程才可能被调度运行<br>-</li></ul><h2 id="main函数执行"><a href="#main函数执行" class="headerlink" title="main函数执行"></a>main函数执行</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</div></pre></td></tr></table></figure><ul><li>内核在调用main前先调用一个特殊的 <em>启动例程</em></li><li>启动例程从内核取得 <em>命令行参数</em> 和 <em>环境变量值</em></li><li>启动例程被指定为程序的起始地址</li></ul><h2 id="进程终止-termination"><a href="#进程终止-termination" class="headerlink" title="进程终止 termination"></a>进程终止 termination</h2><ul><li>正常终止<ul><li>从main返回</li><li>调用exit</li><li>调用 _exit 或 _Exit</li><li>最后一个线程从其启动例程返回</li><li>最后一个线程调用 pthread_exit</li></ul></li><li>异常终止<ul><li>调用abort</li><li>接到一个信号并终止</li><li>最后一个线程对取消请求做出响应</li></ul></li></ul><p>启动例程常常用汇编编写，如果用C代码表示可能是：</p><p>  exit(main(argc, argv));</p><h3 id="exit-函数"><a href="#exit-函数" class="headerlink" title="exit 函数"></a>exit 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</div><div class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</div></pre></td></tr></table></figure><ul><li>_exit 和 _Exit 函数会立即进入内核</li><li>exit则先执行一些清除处理（执行终止处理程序，关闭所有标准IO流）然后进入内核</li><li>三个函数都带有一个整型参数，终止状态，退出状态</li><li>终止状态未定义<ul><li>调用exit时不带终止状态</li><li>main执行一个不带返回值的return</li><li>main没有声明返回整型</li></ul></li><li>终止状态为0<ul><li>返回类型声明为整型，main最后一条语句返回，或隐式返回</li></ul></li></ul><h3 id="atexit-函数"><a href="#atexit-函数" class="headerlink" title="atexit 函数"></a>atexit 函数</h3><p>一个进程可以登记多达32个函数，这些函数由exit自动调用，这些函数称为 <em>终止处理程序</em> exit handler</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line">int atexit(void (*func)(void));</div></pre></td></tr></table></figure><ul><li>参数是一个函数地址</li><li>无需传递任何参数</li><li>也不期望返回值</li><li>调用顺序与登记顺序 <em>相反</em></li><li>多次登记多次调用</li></ul><p><img src="/images/C程序启动和终止.jpeg" alt=""></p><blockquote><p>内核使程序执行的唯一方法是调用一个 exec 函数<br>进程自愿终止的唯一方法是显式或隐式（通过exit）调用 _exit 或 _Exit<br>进程也可非自愿由信号终止</p></blockquote><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><ul><li>执行一个程序时， <em>调用exec的进程</em> 可将命令行参数传递给该新程序</li><li>argv[argc] 是一个空指针 <code>for(i = 0; argv[i] != NULL; i++)</code></li><li>argv[0] 是程序名</li></ul><h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><ul><li>每个程序都会接收到一张环境表</li><li>环境表是一个字符指针数组</li><li>每个指针包含一个以null结束的c字符串地址</li><li>全局变量environ包含该指针数组的地址</li><li><code>extern char **environ;</code></li><li>environ 称为环境指针</li><li>指针数组为环境表</li><li><strong>环境</strong> 由 <em>name=value</em> 这样的字符串组成</li><li>通常用 <code>getenv</code> 和 <code>putenv</code> 函数来访问特定的环境变量</li></ul><p><img src="/images/环境表.jpeg" alt=""></p><h2 id="C程序存储空间布局"><a href="#C程序存储空间布局" class="headerlink" title="C程序存储空间布局"></a>C程序存储空间布局</h2><ul><li>正文段 由CPU执行的机器指令部分，只读，可共享</li><li>初始化数据段 包含了程序中需要明确赋初值的变量</li><li>非初始化数据段 通常称为 bss段<ul><li>内核将此段中数据初始化为0或空指针</li><li>出现在函数外的C声明 <code>long sum[1000];</code> 使此变量存放在非初始化数据段中</li></ul></li><li>栈<ul><li>自动变量</li><li>每次函数调用时所需保存的信息</li><li>每次函数调用时，函数的 <em>返回地址</em> 以及调用者的 <em>环境信息</em> 都存放在栈中</li><li>递归函数每次调用自身，就使用一个新的栈帧</li></ul></li><li>堆<ul><li>在堆中进行动态存储分配</li><li>堆位于非初始化数据段和栈之间</li></ul></li></ul><p><img src="/images/程序存储空间逻辑分布.jpeg" alt=""></p><p>堆顶和栈底之间未用的虚拟地址空间很大</p><blockquote><p>size 命令报告程序正文段，数据段和bss段的长度（字节单位）</p></blockquote><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><ul><li>共享库使得可执行文件不再需要包含公用的库例程</li><li>只需要在所有进程都可引用的存储区中维护这种库例程的副本</li><li>用动态链接方法将程序与共享库函数相链接</li><li>减少了可执行文件的长度，但增加了运行时间开销</li></ul><h2 id="存储器分配"><a href="#存储器分配" class="headerlink" title="存储器分配"></a>存储器分配</h2><p>三个用于存储空间动态分配的函数</p><ul><li>malloc 分配指定字节数的存储区，初始值不确定</li><li>calloc 为 <em>指定数量</em> 具有 <em>指定长度</em> 的对象分配空间，初始为0</li><li>realloc 更改以前分配区的长度，新增区域内的初始值不确定</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</div></pre></td></tr></table></figure><ul><li>返回通用指针 <code>void*</code>，free函数释放的空间通常送入 <em>可用存储区池</em></li><li>分配例程通常用 <code>sbrk</code> 系统调用实现，该系统调用扩充或缩小进程的 <em>堆</em></li><li>已分配区比所要求的要稍大一些，用来记录管理信息</li><li>在已分配区起始位置之前写会重写本块的管理记录，在尾端进行写操作会重写后一个块的管理记录</li><li>其他可能产生的错误：<ul><li>释放一个已经释放的块</li><li>调用free时所用的指针不是三个alloc函数的返回值</li><li>调用malloc却忘了调用free会造成泄露</li></ul></li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>内核不查看这些字符串，它们的解释完全取决于应用程序</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div></pre></td></tr></table></figure><p>返回指针，指向环境字符串<code>name=value</code> 中的value，应该使用getenv而不是直接访问environ</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div></pre></td></tr></table></figure><ul><li>putenv 是取形式为 <code>name=value</code> 的字符串，将其放入环境表中</li><li>setenv 将name设置为value，如果在环境中name已经存在，如果rewrite非0则重写，rewrite为0则不变</li><li>unsetenv 删除name的定义</li></ul><h3 id="修改环境表的操作"><a href="#修改环境表的操作" class="headerlink" title="修改环境表的操作"></a>修改环境表的操作</h3><ul><li>环境表和环境字符串存放在进程存储空间的顶部，栈之上</li><li>修改一个现有的name</li><li>增加一个name，操作更复杂</li></ul><h2 id="setjmp-和-longjmp函数"><a href="#setjmp-和-longjmp函数" class="headerlink" title="setjmp 和 longjmp函数"></a>setjmp 和 longjmp函数</h2><h2 id="getrlimit-和-setrlimit-函数"><a href="#getrlimit-和-setrlimit-函数" class="headerlink" title="getrlimit 和 setrlimit 函数"></a>getrlimit 和 setrlimit 函数</h2><ul><li>每个进程都有一组资源限制</li><li>任何一个进程都可将一个软限制更改为小于或等于其硬限制的值</li><li>任何一个进程都可降低其硬限制值，但必须大于或等于其软限制值，这种降低对普通用户而言不可逆</li><li>只有超级用户进程能提高硬限制值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;进程ID 0 为内核交换进程使用&lt;/li&gt;
&lt;li&gt;init进程进程ID 为1&lt;/li&gt;
&lt;li&gt;init进程的程序文件是 &lt;code&gt;/etc/init&lt;/code&gt; 或 &lt;code&gt;/sbin/init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此进程负责在自举后启动
      
    
    </summary>
    
      <category term="unix" scheme="http://luhaozhao.com/categories/unix/"/>
    
    
      <category term="unix" scheme="http://luhaozhao.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>APUE 系统数据文件</title>
    <link href="http://luhaozhao.com/2017/10/10/apue-%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://luhaozhao.com/2017/10/10/apue-系统数据文件/</id>
    <published>2017-10-10T18:23:22.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使用nobody用户名的目的是，使任何人都可以登录到系统，但不提供任何特权。</li><li><code>finger -p $(whoami)</code> finger 命令打印用户有关信息</li></ul><h2 id="获取口令文件项的函数"><a href="#获取口令文件项的函数" class="headerlink" title="获取口令文件项的函数"></a>获取口令文件项的函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">struct passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</div><div class="line"><span class="function">struct passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div></pre></td></tr></table></figure><h2 id="查看整个口令文件函数"><a href="#查看整个口令文件函数" class="headerlink" title="查看整个口令文件函数"></a>查看整个口令文件函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function">struct passwd *<span class="title">getpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="comment">/* 返回口令文件中的下一个记录项 */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="comment">/* 反绕它所打开的文件，使它们定位到文件开始处 */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="comment">/* 一定要调用endpwent关闭这些文件 */</span></div></pre></td></tr></table></figure><h2 id="阴影文件"><a href="#阴影文件" class="headerlink" title="阴影文件"></a>阴影文件</h2><p>访问阴影口令文件 <code>/etc/passwd</code> 的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">struct spwd *<span class="title">getspnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"><span class="function">struct spwd *<span class="title">getspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure><h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">struct group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</div><div class="line"><span class="function">struct group *<span class="title">getgrnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div></pre></td></tr></table></figure><p>返回指向一个静态变量的指针，在每次调用时都会重写该静态变量。</p><p>搜索整个组文件 <code>/etc/group</code> 的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">struct group *<span class="title">getgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure><h2 id="附加组ID"><a href="#附加组ID" class="headerlink" title="附加组ID"></a>附加组ID</h2><ul><li>以前，每个用户任何时候都只属于一个实际组</li><li><code>newgrp</code> 命令更改组ID</li><li>后来引入附加组ID的概念</li><li>可以属于多达16（常量 <code>NGROUPS_MAX</code> 规定）个另外的组</li><li>文件访问权限检查改为：<ul><li>将进程有效组ID与文件组ID相比较</li><li>将所有附加组ID与文件的组ID进行比较</li></ul></li><li>使用附加组ID的优点是不必显式更改组</li></ul><p>获取和设置附加组ID的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span><span class="params">(<span class="keyword">int</span> gidsetsize, <span class="keyword">gid_t</span> grouplist[])</span></span>;</div><div class="line"><span class="comment">/* 成功返回附加组ID数，出错返回 -1 */</span></div><div class="line"><span class="comment">/* 将附加组ID填写到数组grouplist中，该数组存放元素最多为 gidsetsize 个 */</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">int</span> ngroups, <span class="keyword">const</span> <span class="keyword">gid_t</span> grouplist[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *username, <span class="keyword">gid_t</span> basegid)</span></span>;</div><div class="line"><span class="comment">/* 超级用户调用 */</span></div></pre></td></tr></table></figure><h2 id="其他数据文件"><a href="#其他数据文件" class="headerlink" title="其他数据文件"></a>其他数据文件</h2><ul><li>主机 /etc/hosts</li><li>网络 /etc/networks</li><li>协议 /etc/protocols</li><li>服务 /etc/services</li></ul><h2 id="utmp-和-wtmp-文件"><a href="#utmp-和-wtmp-文件" class="headerlink" title="utmp 和 wtmp 文件"></a>utmp 和 wtmp 文件</h2><ul><li><code>/var/run/utmp</code> 文件 记录当前登录进系统的各个用户</li><li><code>/var/log/wtmp</code> 文件 跟踪各个登录和注销事件</li></ul><p>写入这两个文件中的是下列结构的一条二进制记录</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> &#123;</span></div><div class="line">  <span class="keyword">char</span> ut_line[<span class="number">8</span>];</div><div class="line">  <span class="keyword">char</span> ut_name[<span class="number">8</span>];</div><div class="line">  <span class="keyword">long</span> ut_time;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>登录时，login程序填写此类型结构，然后将其写入utmp文件中，同时添写到wtmp文件中</li><li>注销时，init进程将utmp文件中相应的记录擦除，并将一个新记录添写到wtmp文件中</li></ul><h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(struct utsname *name)</span></span>;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></div><div class="line">  <span class="keyword">char</span> sysname[];</div><div class="line">  <span class="keyword">char</span> nodename[];</div><div class="line">  <span class="keyword">char</span> release[];</div><div class="line">  <span class="keyword">char</span> version[];</div><div class="line">  <span class="keyword">char</span> machine[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>每个数组的长度由实现确定，以上是该结构至少需要提供的字段</p><ul><li>hostname 命令可用来获取和 <em>设置</em> 主机名</li></ul><h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><ul><li>日历时间 <code>time_t</code></li><li>以国际标准时间而非本地时间计时</li><li>可自动进行转换</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *calptr);</div></pre></td></tr></table></figure><p>返回当前时间值，如果参数不为空，则时间值也会存放在 calptr 指向的单元里</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *<span class="keyword">restrict</span> tp, <span class="keyword">void</span> *<span class="keyword">restrict</span> tzp)</span></span>;</div></pre></td></tr></table></figure><ul><li>gettimeofday 提供更高的分辨率，最高为微秒级</li><li>tzp 唯一合法值是NULL</li><li>其他tzp值产生不确定结果</li><li>某些平台支持用tzp说明时区</li><li>当前时间存放在tp指向的timeval结构中</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></div><div class="line">  <span class="keyword">time_t</span> tv_sec;</div><div class="line">  <span class="keyword">long</span> tv_usec;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/* 该结构存储秒和微妙 */</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;使用nobody用户名的目的是，使任何人都可以登录到系统，但不提供任何特权。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finger -p $(whoami)&lt;/code&gt; finger 命令打印用户有关信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;获取口令文件项的函数&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="unix" scheme="http://luhaozhao.com/categories/unix/"/>
    
    
      <category term="unix" scheme="http://luhaozhao.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>APUE 标准IO库</title>
    <link href="http://luhaozhao.com/2017/10/09/apue-%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
    <id>http://luhaozhao.com/2017/10/09/apue-标准IO库/</id>
    <published>2017-10-09T10:30:13.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<ul><li>不仅仅在UNIX上，很多操作系统都实现了标准I/O库</li><li>标准IO库处理很多细节：缓冲区分配、优化长度执行I/O等</li></ul><h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><ul><li>不带缓冲的I/O函数都是针对 <em>文件描述符</em> 的，对于标准IO库，它们的操作都是围绕流进行的</li><li>用标准IO库打开或创建一个文件，就使得 <strong>一个流</strong> 与 <strong>一个文件</strong> 相关联。</li><li>文件流的 <strong>字宽</strong> 表示文件流用于 <em>单字节</em> 还是 <em>多字节</em> 字符集</li><li><strong>流的定向</strong> 决定了文件流的字宽</li><li>一个文件流创建时，它没有定向</li><li>在未定向的流上使用 <em>多字节IO函数</em> 则流的定向会设置为 <em>宽定向</em></li><li>在未定向的流上使用 <em>单字节IO函数</em> 则流的定向会设置为 <em>字节定向</em></li><li>freopen 函数清除流的定向</li><li>fwide 函数设置流的定向</li></ul><h3 id="fwide-函数"><a href="#fwide-函数" class="headerlink" title="fwide 函数"></a>fwide 函数</h3><blockquote><p>mode 不会改变已定向流的定向</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* 流是宽定向返回正值 */</span></div><div class="line"><span class="comment">/* 流是字节定向返回负值 */</span></div><div class="line"><span class="comment">/* 流是未定向返回0 */</span></div></pre></td></tr></table></figure><ul><li>mode 为负，fwide 试图使流字节定向</li><li>mode 为正，fwide 试图使流宽定向</li><li>mode 为0，fwide 不设置流的定向，但返回标识该流定向的值</li><li>fwide 无出错返回，只能先清除通过检查 errno的值</li></ul><h3 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h3><p>fopen 返回一个指向FILE对象的指针，FILE对象通常是一个结构，包含标准IO库管理流的信息</p><ul><li>用于实际IO的文件描述符</li><li>指向用于该 <em>流缓冲区</em> 的指针</li><li>缓冲区的长度</li><li>当前缓冲区中的字符数</li><li>出错标志</li></ul><p>为了引用一个流，将FILE指针作为参数传递给标准IO函数，FILE对象的指针称为 <em>文件指针</em></p><h2 id="标准输入-输出-出错"><a href="#标准输入-输出-出错" class="headerlink" title="标准输入 输出 出错"></a>标准输入 输出 出错</h2><p>进程预定义的三个流，三个预定义文件指针，定义在头文件 <stdio.h> 中</stdio.h></p><ul><li>stdin</li><li>stdout</li><li>stderr</li></ul><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><h3 id="缓冲的目的"><a href="#缓冲的目的" class="headerlink" title="缓冲的目的"></a>缓冲的目的</h3><ul><li>尽可能减少使用 read 和 write 函数的次数</li><li>对每个IO流自动进行缓冲管理，避免应用程序需要考虑这点</li></ul><h3 id="缓冲类型"><a href="#缓冲类型" class="headerlink" title="缓冲类型"></a>缓冲类型</h3><ul><li>全缓冲 填满标准IO缓冲区后才进行实际IO操作<ul><li>调用 malloc 获得需要使用的缓冲区</li><li>冲洗 flush 说明标准IO缓冲区的 <em>写操作</em></li><li>自动冲洗（写满时）或 调用函数 fflush 冲洗</li></ul></li><li>行缓冲 在输入和输出中遇到换行符进行IO操作<ul><li>流涉及一个终端时（例如标准输入和标准输出）通常使用行缓冲</li><li>当填满缓冲区，即使没有写一个换行符也进行IO操作</li><li>从不带缓冲的流或一个行缓冲的流得到输入数据，那么就会造成冲洗所有行缓冲输出流</li></ul></li><li>不带缓冲 标准IO库不对字符进行缓冲存储<ul><li>标准错误流 stderr通常是不带缓冲的</li></ul></li></ul><h3 id="改变缓冲类型"><a href="#改变缓冲类型" class="headerlink" title="改变缓冲类型"></a>改变缓冲类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</div></pre></td></tr></table></figure><ul><li>这些函数需要在已打开的流上调用</li><li>并应该在对流执行其他操作前调用</li><li>setbuf 函数buf参数指向一个长度为 <code>BUFSIZ</code>的缓冲区，就是带缓冲进行IO （系统设置全缓冲还是行缓冲）</li><li>setbuf 函数buf参数设置为NULL 就是关闭缓冲</li><li>setvbuf 精确指定缓冲类型，根据mode参数指定<ul><li>_IOFBF 全缓冲 (buf是NULL 则自动为流分配合适长度的系统缓冲区)</li><li>_IOLBF 行缓冲 (buf是NULL 则自动为流分配合适长度的系统缓冲区)</li><li>_IONBF 不带缓冲（忽略buf和size参数）</li></ul></li></ul><p>有些实现缓冲区的一部分用于存放它自己的管理操作信息，所以可以存放在缓冲区中的实际数据字节数会 <strong>少于size</strong></p><h3 id="fflush-冲洗流"><a href="#fflush-冲洗流" class="headerlink" title="fflush 冲洗流"></a>fflush 冲洗流</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure><p>一个特例：当fp是 NULL 时，则此函数会导致<strong>所有输出流</strong>被冲洗。</p><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div></pre></td></tr></table></figure><ul><li>fopen 打开一个指定的文件</li><li>freopen 在指定流上打开一个指定的文件<ul><li>如果流已经打开，则先关闭流</li><li>如果流已经定向，则清除该定向</li><li>一般用于将一个指定的文件打开为预定义的流（标准输入 标准输出 标准出错）</li></ul></li><li>fdopen 使标准的IO流与现有的文件描述符相结合<ul><li>常用于由创建管道和网络通信通道函数返回的描述符（因为这些特殊类型的文件不能用标准IO fopen函数打开）</li></ul></li></ul><p>type参数</p><ul><li>r 或 rb 读</li><li>w 或 wb 文件截短为0 或为写而创建</li><li>a 或 ab 添加；在文件尾写</li><li>r+ 或 r+b 或 rb+ 读和写</li><li>w+ 或 w+b 或 wb+ 把文件截短为0，读写</li><li>a+ 或 a+b 或 ab+ 在文件尾读写</li></ul><p>字符b 作为type的一部分，使得标准IO可以区分文本文件和二进制文件<br>unix内核不区分这两种文件</p><ul><li>如果有多个进程用标准IO添写方式打开同一个文件，那么来自每个进程的数据都将正确地写到文件中</li></ul><h3 id="fclose-关闭一个流"><a href="#fclose-关闭一个流" class="headerlink" title="fclose 关闭一个流"></a>fclose 关闭一个流</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure><p>文件被关闭前，冲洗缓冲区中的输出数据。丢弃缓冲区中的任何 <em>输入数据</em><br>一个进程正常终止时，则所有带未写缓冲数据的标准IO都会被冲洗，所有打开的标准IO都会被关闭</p><h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><ul><li>每次一个字符的IO</li><li>每次一行的IO</li><li>直接IO （常用于二进制文件中读或写一个结构）</li></ul><h3 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* 返回下一个字符 */</span></div><div class="line"><span class="comment">/* 达到文件尾或出错返回EOF */</span></div></pre></td></tr></table></figure><blockquote><p>getchar 等价于 getc(stdin)</p></blockquote><ul><li>fgetc 一定是一个函数，不能实现为宏，允许将其地址作为一个参数传送</li><li>getc的参数不应当具有副作用的表达式</li><li>调用fgetc所需时间很可能长于调用getc，因为调用函数通常所需时间长于调用宏</li></ul><h3 id="区分出错还是到达文件尾"><a href="#区分出错还是到达文件尾" class="headerlink" title="区分出错还是到达文件尾"></a>区分出错还是到达文件尾</h3><p>每个流在FILE对象中维持两个标志：</p><ul><li>出错标志</li><li>文件结束标志</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure><h3 id="ungetc-将字符再压送回流中"><a href="#ungetc-将字符再压送回流中" class="headerlink" title="ungetc 将字符再压送回流中"></a>ungetc 将字符再压送回流中</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div></pre></td></tr></table></figure><ul><li>当已经到达文件尾端时，仍可以回送一个字符，下次读将返回这个字符，再次读则返回EOF</li><li>ungetc函数会清除流的文件结束标志</li></ul><h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div></pre></td></tr></table></figure><ul><li>putchar(c) 等效于 putc(c, stdout)</li><li>putc 可实现为宏</li><li>fputc不能实现为宏</li></ul><h2 id="每次一行I-O"><a href="#每次一行I-O" class="headerlink" title="每次一行I/O"></a>每次一行I/O</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</div></pre></td></tr></table></figure><ul><li>gets从标准输入读</li><li>fgets从指定的流读</li><li>指定缓冲区的地址，读入的行送入其中</li><li>fgets 指定缓冲区的长度 n</li><li>一直读到下一个换行符为止，但不超过n-1个字符</li><li>缓冲区以null字符结尾</li><li>gets不推荐使用，因为不能指定缓冲区长度，可能造成缓冲区溢出，写到缓冲区后面的存储空间</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</div></pre></td></tr></table></figure><ul><li>将一个以null符终止的字符串写到指定流，但null不写出</li><li>不要求null字符之前一定是换行符，通常null符之前是一个换行符</li><li>puts会自动在最后添加一个换行符</li></ul><h2 id="标准IO的效率"><a href="#标准IO的效率" class="headerlink" title="标准IO的效率"></a>标准IO的效率</h2><h2 id="二进制IO"><a href="#二进制IO" class="headerlink" title="二进制IO"></a>二进制IO</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div></pre></td></tr></table></figure><ul><li>size 每个元素的长度</li><li>nobj 为元素个数</li><li>ptr 读或写的对象指针</li><li>返回读或写的对象数</li><li>只能用于读在同一系统上已写的数据</li><li>异构系统的成员偏移量因编译器和系统而不同、存储多字节整数和浮点值的二进制格式也可能不同</li><li>在不同系统之间交换二进制数据的实际解决方式是使用较高级的协议</li></ul><h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure><h2 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div></pre></td></tr></table></figure><ul><li>printf 将格式化数据写到标准输出</li><li>fprintf 写到指定流</li><li>sprintf 将格式化字符送入数组buf中，在该数组的尾端自动加一个null字节</li><li>sprintf 可能会造成buf 指向的缓冲区溢出，调用者有责任确保缓冲区足够大</li><li>snprintf 缓冲区长度是一个显式参数n 超过缓冲区尾端写的字符会被丢弃</li><li>以上函数返回输出字节数，但不计算null字节，发生编码错误会返回负值</li></ul><h3 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</div></pre></td></tr></table></figure><p>类型转换</p><ul><li>d 有符号十进制</li><li>i 有符号十进制，基数由输入格式决定</li><li>o 无符号八进制</li><li>u 无符号十进制</li><li>x 无符号十六进制</li><li>a A e E f F g G 浮点数</li><li>c 字符</li><li>s 字符串</li><li>p void指针</li><li>% %字符</li><li>C 宽字符</li><li>S 宽字符</li><li>[ 匹配列出的字符序列</li></ul><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>标准IO库最终要调用IO例程，每个标准IO流都有一个与其相关联的文件描述符</p><p>可以对一个流调用fileno函数获得其描述符。</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure><ul><li>tmpnam 产生一个有效路径名字符串</li><li>ptr是NULL 则路径名放在一个静态区中，指向静态区的指针作为函数值返回</li><li>若ptr不是NULL则认为它指向长度至少是L_tmpnam个字符的数组，路径名放数组中，ptr也作为函数值返回</li><li>tmpfile创建一个 <em>临时二进制文件</em> <code>wb+</code> 在关闭该文件或程序结束时自动删除这种文件</li><li>tmpfile的实现<ul><li>先调用tmpnam产生唯一路径名</li><li>然后用该路径名创建一个文件</li><li>并立即unlink</li><li>解除链接不会删除内容，关闭文件时才删除</li></ul></li></ul><h3 id="tempnam-函数"><a href="#tempnam-函数" class="headerlink" title="tempnam 函数"></a>tempnam 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tempnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *directory, <span class="keyword">const</span> <span class="keyword">char</span> *prefix)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</div></pre></td></tr></table></figure><p>是tmpnam的一个变体，允许指定目录和前缀</p><ul><li>如果定义了环境变量TMPDIR 则用其作为目录</li><li>如果directory非null 则作为目录</li><li>将<code>&lt;stdio.h&gt;</code> 中的字符串 P_tmpdir 作为目录</li><li>将本地目录 <code>/tmp</code> 用作目录</li><li>如果prefix非null 它应该最多包含5个字符的字符串</li><li>该函数调用 malloc 函数分配动态存储区，用其存放构造的路径名</li><li>mkstemp 返回文件描述符，并且创建的临时文件不会自动被删除</li><li>tmpnam和tempnam的不足之处：在返回唯一路径名和应用程序用该路径名创建文件之间有一个时间窗口，在这期间另一进程可能创建同名文件</li><li>tempfile 和 mkstemp 不会有这种问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;不仅仅在UNIX上，很多操作系统都实现了标准I/O库&lt;/li&gt;
&lt;li&gt;标准IO库处理很多细节：缓冲区分配、优化长度执行I/O等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;流和FILE对象&quot;&gt;&lt;a href=&quot;#流和FILE对象&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="unix" scheme="http://luhaozhao.com/categories/unix/"/>
    
    
      <category term="unix" scheme="http://luhaozhao.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>APUE 文件和目录</title>
    <link href="http://luhaozhao.com/2017/09/22/apue-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>http://luhaozhao.com/2017/09/22/apue-文件和目录/</id>
    <published>2017-09-22T15:11:19.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="stat-fstat-lstat-函数"><a href="#stat-fstat-lstat-函数" class="headerlink" title="stat fstat lstat 函数"></a>stat fstat lstat 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, struct stat *buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</div></pre></td></tr></table></figure><ul><li>lstat 返回符号链接的有关信息，而不是由符号链接引用的文件的信息</li><li>指针 buf 指向一个我们提供的结构</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></div><div class="line">  <span class="keyword">mode_t</span> st_mode; <span class="comment">/* 文件类型 &amp; 权限位 */</span></div><div class="line">  <span class="keyword">ino_t</span> st_ino; <span class="comment">/* i节点编号 */</span></div><div class="line">  <span class="keyword">dev_t</span> st_dev; <span class="comment">/* 设备号（文件系统） */</span></div><div class="line">  <span class="keyword">dev_t</span> st_rdev; <span class="comment">/* 特殊文件设备号，XSI扩展 */</span></div><div class="line">  <span class="keyword">nlink_t</span> st_nlink; <span class="comment">/* 链接数 */</span></div><div class="line">  <span class="keyword">uid_t</span> st_uid; <span class="comment">/* 文件所有者用户ID */</span></div><div class="line">  <span class="keyword">gid_t</span> st_gid; <span class="comment">/* 文件所有者组ID */</span></div><div class="line">  <span class="keyword">off_t</span> st_size; <span class="comment">/* 普通文件字节大小 */</span></div><div class="line">  <span class="keyword">time_t</span> st_atime; <span class="comment">/* 最后访问时间 */</span></div><div class="line">  <span class="keyword">time_t</span> st_mtime; <span class="comment">/* 文件内容最后修改时间 */</span></div><div class="line">  <span class="keyword">time_t</span> st_ctime; <span class="comment">/* 文件属性最后更改时间 */</span></div><div class="line">  <span class="keyword">blksize_t</span> st_blksize; <span class="comment">/* 最优I/O块大小，XSI扩展 */</span></div><div class="line">  <span class="keyword">blkcnt_t</span> st_blocks; <span class="comment">/* 分配的块数目，XSI扩展 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li>普通文件<ul><li>文本还是二进制对于Unix内核而言无区别</li><li>二进制可执行文件应该遵循一种格式，以使内核能确定程序文本和数据的加载位置</li></ul></li><li>目录文件<ul><li>包含了其他 <em>文件的名字</em> 以及指向这些文件有关 <em>信息的指针</em></li><li>对目录文件具有 <em>读权限</em> 的进程可以读取该目录的内容</li><li>只有内核可以直接写目录文件</li><li>进程必须使用特定函数才能更改目录</li></ul></li><li>块特殊文件 block special file<ul><li>提供对设备 <em>带缓冲</em> 的访问</li><li>每次访问以固定长度为单位进行</li></ul></li><li>字符特殊文件 character special file<ul><li>提供对设备 <em>不带缓冲</em> 的访问</li><li>每次访问长度可变</li></ul></li><li>FIFO<ul><li>用于进程间通信</li><li>有时也称为 <em>命名管道</em> named pipe</li></ul></li><li>socket<ul><li>用于进程间网络通信</li><li>也可用于一台宿主机上进程间非网络通信</li></ul></li><li>符号链接 symbolic link</li></ul><p>可用宏去确定文件类型，宏的参数是 <code>stat.st_mode</code></p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISDIR(mode) ((mode) &amp; S_IFMT == S_IFDIR) <span class="comment">/* 宏的定义 */</span></span></div></pre></td></tr></table></figure><ul><li><code>S_ISREG()</code></li><li><code>S_ISDIR()</code></li><li><code>S_ISCHR()</code> 字符特殊文件</li><li><code>S_ISBLK()</code> 块特殊文件</li><li><code>S_ISFIFO()</code> 管道或FIFO</li><li><code>S_ISLNK()</code> 符号链接</li><li><code>S_ISSOCK()</code> 套接字</li></ul><h2 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h2><ul><li>我们实际上谁<ul><li>实际用户 ID</li><li>实际组 ID</li></ul></li><li>用于文件访问权限检查<ul><li>有效用户 ID</li><li>有效组 ID</li><li>附加组 ID</li></ul></li><li><p>由exec函数保存</p><ul><li>保存的设置用户 ID</li><li>保存的设置组 ID</li><li>在执行一个程序时包含了有效用户ID 有效组ID的副本</li></ul></li><li><p>进程的有效用户ID通常是实际用户ID</p><ul><li>当文件模式 <code>st_mode</code> 设置了 <em>设置用户ID</em> 或 <em>设置组ID</em> 后</li><li>可以使得进程的有效用户ID 或 有效组ID 设置为 <em>文件所有者或所有组</em> 的ID</li><li>这种进程是一个 <em>设置用户(组)ID程序</em></li><li>可用常量<code>S_ISUID</code> 和 <code>S_ISGID</code> 测试设置ID位</li></ul></li></ul><h3 id="打开设置用户id位"><a href="#打开设置用户id位" class="headerlink" title="打开设置用户id位"></a>打开设置用户id位</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># chown u+s foo</span></div></pre></td></tr></table></figure><h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><ul><li><code>S_IRUSR</code></li><li><code>S_IWUSR</code></li><li><code>S_IXUSR</code></li><li><code>S_IRGRP</code></li><li><code>S_IWGRP</code></li><li><code>S_IXGRP</code></li><li><code>S_IROTH</code></li><li><code>S_IWOTH</code></li><li><p><code>S_IXOTH</code></p></li><li><p>对路径中的每个目录都应该具有 <em>执行权限</em></p></li><li>目录执行权限位常被称为 <em>搜索位</em></li><li>对目录的读权限允许获取该目录的文件名列表 与目录执行权限不同，注意区别</li><li>如果PATH环境变量指定了一个我们不具有执行权限的目录，shell不会在该目录下找到可执行文件</li><li>删除一个现有的文件，必须对包含该文件的目录具有写权限和执行权限，对文件本身不需要读写权限</li></ul><h3 id="文件访问权限测试"><a href="#文件访问权限测试" class="headerlink" title="文件访问权限测试"></a>文件访问权限测试</h3><p>内核进行的测试是：</p><ul><li>若进程的有效用户ID是0 则允许访问</li><li>若进程有效用户ID等于文件所有者ID，若 <em>所有者</em> 适当的访问权限(rwx)被设置，允许访问，否则拒绝访问</li><li>若进程有效组ID或进程附加组ID之一等于文件组ID，若 <em>组</em> 适当的访问权限位被设置 …</li><li>若其他用户适当的访问权限位被设置 …</li></ul><p>匹配了第二步（有效用户ID），就不会看第三步（有效组ID）</p><h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><ul><li>新文件的用户ID设置为进程的有效用户ID</li><li>新文件的组ID<ul><li>可以是进程的有效组ID</li><li>可以是它所在目录的组ID （继承目录的组ID）</li></ul></li></ul><h2 id="access-函数"><a href="#access-函数" class="headerlink" title="access 函数"></a>access 函数</h2><p>access函数是按 <em>实际用户ID</em> 和 <em>实际组ID</em> 进行访问权限测试的<br>测试也分为四步，与上面的有效ID测试差不多，但把有效ID改为实际ID</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"><span class="comment">/* 测试通过返回0 否则-1 */</span></div></pre></td></tr></table></figure><p>mode是下面常量的 <strong>位或</strong></p><ul><li>R_OK</li><li>W_OK</li><li>X_OK</li><li>F_OK 测试文件是否存在</li></ul><h2 id="umask-函数"><a href="#umask-函数" class="headerlink" title="umask 函数"></a>umask 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</div><div class="line"><span class="comment">/* 返回以前的文件模式创建屏蔽字 */</span></div></pre></td></tr></table></figure><ul><li>文件模式创建屏蔽字</li><li>屏蔽字与进程相关联，umask函数则可以为进程设置屏蔽字</li><li>参数 <code>cmask</code> 是由那9个常量中若干个 <em>按位或</em> 构成的</li><li>屏蔽字中为1的位，在文件mode中相应位则一定被关闭</li><li>更改进程的文件模式创建屏蔽字并 <em>不影响</em> 父进程的屏蔽字</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">umask</span> -S <span class="comment"># 以符号形式打印屏蔽字</span></div></pre></td></tr></table></figure><h2 id="chmod-fchmod-函数"><a href="#chmod-fchmod-函数" class="headerlink" title="chmod fchmod 函数"></a>chmod fchmod 函数</h2><p>更改现有文件的访问权限</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="comment">/* 成功返回0 否则-1 */</span></div></pre></td></tr></table></figure><ul><li>新创建文件的组ID 可能不是调用进程所属的组，新文件的组ID可能是父目录的组ID</li><li>如果新文件的组ID不等于进程的有效组ID或进程附加组ID中的一个，以及进程没有超级用户权限，那么 <strong>设置组ID位将自动关闭</strong></li><li>防止用户创建一个设置组ID文件</li><li>只有超级用户才能设置普通文件的粘滞位</li></ul><h3 id="改变文件的权限位要求"><a href="#改变文件的权限位要求" class="headerlink" title="改变文件的权限位要求"></a>改变文件的权限位要求</h3><ul><li>进程有效用户ID 等于 文件所有者ID</li><li>或者进程具有超级用户权限</li></ul><h3 id="参数mode"><a href="#参数mode" class="headerlink" title="参数mode"></a>参数mode</h3><p>mode 由下面常量按位或组成</p><ul><li>S_ISUID 执行时设置用户ID</li><li>S_ISGID 执行时设置组ID</li><li>S_ISVTX 保存正文常量 <em>粘滞位</em></li><li>S_IRWXU 组合常量<ul><li>S_IRUSR</li><li>S_IWUSR</li><li>S_IXUSR</li></ul></li><li>S_IRWXG 组合常量<ul><li>S_IRGRP</li><li>S_IWGRP</li><li>S_IXGRP</li></ul></li><li>S_IRWXO 组合常量<ul><li>S_IROTH</li><li>S_IWOTH</li><li>S_IXOTH</li></ul></li></ul><h2 id="粘滞位-S-ISVTX"><a href="#粘滞位-S-ISVTX" class="headerlink" title="粘滞位 S_ISVTX"></a>粘滞位 S_ISVTX</h2><p>sticky bit</p><p>早期粘滞位作用</p><ul><li>早期的Unix系统未使用分页技术，设置了粘滞位的可执行程序正文部分（机器指令部分）会保存副本在交换区（使得下次执行程序能更快装入内存区）</li><li>交换区占用连续磁盘空间，可视为连续文件（一般文件的数据块可能是随机存放的，不是连续文件）</li><li>系统再次自举前，文件的正文部分总是在交换区中，所以使用了名字 <em>粘住</em> 后来称为 <em>保存正文位</em></li><li>现在的Unix系统都有配置 <strong>虚拟存储系统</strong> 以及 <strong>快速文件系统</strong> 所以不再需要这种技术</li></ul><p>现在粘滞位的使用</p><p>对目录设置粘滞位，可以保护目录下的文件不会轻易被删除或改名，需要满足以下条件才能删改：</p><ul><li>对目录具有写权限</li><li>三选一<ul><li>拥有此文件</li><li>拥有此目录</li><li>是超级用户</li></ul></li></ul><p>实际应用是 <code>/tmp</code> 目录的权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 设置粘滞位</span></div><div class="line">chmod +t /foo</div><div class="line">chmod 1777 /foo</div><div class="line"><span class="comment"># 清除粘滞位</span></div><div class="line">chmod -t /foo</div><div class="line">chmod 0777 /foo</div></pre></td></tr></table></figure><h2 id="chmod-fchown-lchown函数"><a href="#chmod-fchown-lchown函数" class="headerlink" title="chmod fchown lchown函数"></a>chmod fchown lchown函数</h2><p>更改文件的用户ID和组ID</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</div><div class="line"><span class="comment">/* 成功返回0 否则返回-1 */</span></div></pre></td></tr></table></figure><ul><li>若参数 <code>owner</code> 或 <code>group</code> 任意一个是 <em>-1</em> 则对应的ID <strong>不变</strong></li></ul><p>若 <code>_POSIX_CHOWN_RESTRICTED</code> 对指定的文件起作用</p><ul><li>只有超级用户进程能更改文件的用户ID</li><li>满足以下条件，一个非超级用户进程可以更改该文件的 <strong>组ID</strong><ul><li>进程拥有此文件（有效用户ID等于文件用户ID）</li><li>参数owner等于-1 或文件的用户ID ，并且参数 group 等于进程的有效组ID或附加组ID之一</li></ul></li></ul><p>以上意味着当<code>_POSIX_CHOWN_RESTRICTED</code>起作用时，</p><ul><li>不能更改其他用户文件的用户ID</li><li>可以更改你拥有的文件的组ID，但只能改到你所属的组</li></ul><h3 id="非超级用户调用，设置位会被清除"><a href="#非超级用户调用，设置位会被清除" class="headerlink" title="非超级用户调用，设置位会被清除"></a>非超级用户调用，设置位会被清除</h3><p>如果函数由 <em>非超级用户</em> 调用，则在成功返回时，该文件的 <em>设置用户ID位</em> 和 <em>设置组ID位</em> 会被清除</p><h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><ul><li>stat 结构成员 st_size表示</li><li>以字节为单位的文件长度</li><li>读文件长度为0时，将得到 end-of-file 指示</li><li>此字段只对普通文件、目录文件和符号链接有意义</li><li>符号链接文件长度是文件名中的实际字节数</li><li>st_blksize 是对文件I/O较合适的块长度</li><li>st_blocks 是分配的实际512字节块数量 (不同Unix版本其st_blocks所用单位可能不是512字节)</li></ul><h3 id="文件空洞"><a href="#文件空洞" class="headerlink" title="文件空洞"></a>文件空洞</h3><ul><li>空洞是由所设置的偏移量超过文件尾端，并写了某些数据后造成的</li><li>空洞影响文件大小，但不占用磁盘空间</li></ul><h2 id="文件截短"><a href="#文件截短" class="headerlink" title="文件截短"></a>文件截短</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">off_t</span> length)</span></span>;</div></pre></td></tr></table></figure><ul><li>这两个函数将把现有文件的长度截短为length字节，超过部分不再能访问。</li><li>如果length大于以前的长度，遵循XSI的系统可以增加文件长度，填入空洞。</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ul><li>一个磁盘分成一个或多个<strong>分区</strong></li><li>每个分区包含一个<strong>文件系统</strong></li><li>文件系统里有多个柱面组</li><li>每个柱面组里有 <em>i节点部分</em> 和 <em>数据块部分</em> <em>目录块部分</em></li><li>目录项指向i节点项</li><li>节点项指向数据块</li><li>每个i节点都有 <em>链接计数</em> （指向该i节点的目录项数）</li><li>链接计数包含在 <code>st_nlink</code> 成员中，类型为 <code>nlink_t</code> 这种链接类型为 <em>硬链接</em></li><li>符号链接文件的i节点中的文件类型是 <code>S_IFLNK</code> 文件实际内容包含了指向的文件的名字</li><li>i节点包含的信息<ul><li>文件类型</li><li>文件访问权限位</li><li>文件长度</li><li>指向文件所占用的数据块指针</li><li>但 <strong>文件名</strong> 是存放在目录项中的</li><li><strong>i节点编号</strong> 是存放在目录项中的</li></ul></li><li>i节点编号的数据类型是 <code>ino_t</code></li><li>每个文件系统对它们的i节点进行编号，因此不能使一个目录项指向另一个文件系统的i节点</li><li>因此硬链接不能跨文件系统</li><li>在同一文件系统下为文件改名的步骤<ul><li>构建一个指向现有i节点的新目录项</li><li>解除旧目录项的链接</li><li>这就是mv命令的通常操作</li></ul></li></ul><h3 id="普通文件的链接计数"><a href="#普通文件的链接计数" class="headerlink" title="普通文件的链接计数"></a>普通文件的链接计数</h3><p>目录块.目录项.i节点号 -&gt; i节点.数据块指针(可能有多个指针) -&gt; 文件内容数据块(可能有多个数据块)</p><h3 id="目录的链接计数"><a href="#目录的链接计数" class="headerlink" title="目录的链接计数"></a>目录的链接计数</h3><p>目录块.目录项(.或..或其它目录文件).i节点号 -&gt; i节点.数据块指针 -&gt; 目录块</p><ul><li>任何一个叶目录的链接计数总是2</li><li>父目录中的每一个子目录会使该父目录的链接计数增加1</li></ul><h2 id="link-unlink-remove-rename函数"><a href="#link-unlink-remove-rename函数" class="headerlink" title="link unlink remove rename函数"></a>link unlink remove rename函数</h2><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpaht, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</div><div class="line"><span class="comment">/* 成功返回0 否则-1 */</span></div></pre></td></tr></table></figure><ul><li>创建一个指向现有文件的链接</li><li>很多文件系统不允许对目录硬链接</li><li>如果文件系统允许创建目录硬链接，也仅限于超级管理员</li></ul><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"><span class="comment">/* 成功返回0 否则-1 */</span></div></pre></td></tr></table></figure><ul><li>函数用于删除目录项，并将文件的链接计数减1</li><li>解除链接需要对包含该目录项的<strong>目录</strong>有 <em>写</em> 和 <em>执行</em> 的权限</li><li>还要看目录是否设置了粘滞位<ul><li>设置了粘滞位则需要满足以下条件之一才能解除链接</li><li>拥有该文件</li><li>拥有该目录</li><li>具有超级用户权限</li></ul></li><li>只有当链接计数达到0，文件内容才会被删除</li><li>另外如果有进程打开了该文件，内容也不能删除</li><li>关闭一个文件时，<strong>内核</strong>先检查打开该文件的进程，再检查链接数，最后才决定删除</li><li>这种性质经常被程序用来确保及时在程序崩溃时，程序创建的临时文件也不会遗留下来<ul><li>进程用open或creat创建一个文件</li><li>然后立即调用unlink</li><li>当进程关闭该文件或终止时，文件内容会被删除</li></ul></li></ul><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"><span class="comment">/* 成功返回0 否则-1 */</span></div></pre></td></tr></table></figure><ul><li>对于文件 remove 相当于 unlink</li><li>对于目录 remove相当于 rmdir</li><li>ISO C指定remove函数删除一个文件，原因是实现C标准的大多数非UNIX系统不支持文件链接</li></ul><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</div><div class="line"><span class="comment">/* 成功返回0 否则-1 */</span></div></pre></td></tr></table></figure><ul><li>如果引用符号链接，则处理的是符号链接本身</li><li>如果两个参数引用同一个文件，则函数不做任何更改而成功返回</li><li>可以对目录改名，newname如果存在则应该是空目录，newname不能包含oldname作为起路径前缀</li><li>如果newname是一个存在的文件，则会删除newname目录项，然后再更名</li></ul><h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><ul><li>任何用户都可创建指向目录的符号链接</li><li>没有文件系统的限制</li><li>要留意某些函数是否跟随符号链接</li><li>unlink 函数不跟随符号链接</li><li>在一个目录中创建一个符号链接 指向父目录 会构成循环链接</li><li>这种循环可以用unlink消除，但如果是硬链接就很难消除，因此不允许构造指向目录的硬链接</li><li><code>ls -F</code> 会在符号链接的文件名后面加一个 <code>@</code> 符号</li></ul><h2 id="symlink-和-readlink函数"><a href="#symlink-和-readlink函数" class="headerlink" title="symlink 和 readlink函数"></a>symlink 和 readlink函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</div><div class="line"><span class="comment">/* 成功返回0 否则-1 */</span></div></pre></td></tr></table></figure><ul><li>symlink函数创建一个符号链接</li><li>不要求actualpath已经存在</li><li>actualpath 和 sympath 并不需要位于同一文件系统中</li><li>open 函数跟随符号链接，readlink函数打开符号链接本身</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize);</div><div class="line"><span class="comment">/* 成功返回读到的字节数 否则-1 */</span></div></pre></td></tr></table></figure><h2 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h2><ul><li>st_atime 文件数据最后访问时间</li><li>st_mtime 文件数据最后修改时间 <em>修改时间</em></li><li>st_ctime i节点状态的最后修改时间 <em>状态时间</em></li><li>系统不会保存i节点的最后一次访问时间 所以access 和stat函数不更改这些时间</li><li>ls命令的时间选项<ul><li><code>-t</code> 默认按修改时间先后排序</li><li><code>-u</code> 按访问时间排序</li><li><code>-c</code> 按状态更改时间排序</li></ul></li></ul><h2 id="utime-函数"><a href="#utime-函数" class="headerlink" title="utime 函数"></a>utime 函数</h2><p>utime函数用来更改一个文件的访问时间和修改时间</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utime.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct utimbuf *times)</span></span>;</div><div class="line"><span class="comment">/* 成功返回0 否则-1 */</span></div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> &#123;</span></div><div class="line">  <span class="keyword">time_t</span> actime; <span class="comment">/* access time 访问时间 */</span></div><div class="line">  <span class="keyword">time_t</span> modtime; <span class="comment">/* modification time 修改时间 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>权限要求：进程的有效用户ID必须等于文件的所有者ID 或超级用户进程</li><li>如果times指针是一个空指针 则两个时间都设置为当前时间</li><li>当调用utime函数时，文件的状态修改时间会自动更新</li></ul><h2 id="mkdir-和-rmdir-函数"><a href="#mkdir-和-rmdir-函数" class="headerlink" title="mkdir 和 rmdir 函数"></a>mkdir 和 rmdir 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div></pre></td></tr></table></figure><ul><li>该函数创建一个新的空目录，其中 . 和 .. 目录项会自动创建</li><li>所指定的文件访问权限 mode 由 <em>进程</em> 的 <em>文件模式创建屏蔽字</em> 修改</li><li>目录通常至少要设置一个 <em>执行权限位</em> 以允许访问该目录中的文件名</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div></pre></td></tr></table></figure><ul><li>删除一个空目录</li><li>使目录的链接计数为0，目录中不能再创建新文件，进程关闭后释放目录占用的空间</li></ul><h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><ul><li>对目录有访问权限的用户可以读目录</li><li>但只有内核可以写目录，为了防止文件系统产生混乱</li><li>目录的写权限不表示写目录本身，只是创建新文件和删除文件</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"><span class="comment">/* 成功返回指针，出错返回nul */</span></div><div class="line"></div><div class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span></span>;</div></pre></td></tr></table></figure><ul><li>DIR 结构是一个内部结构</li><li>该结构保存当前正被读的目录的有关信息</li><li>作用类似 FILE 结构</li><li>目录中各目录项的顺序与实现有关，通常不按字母排序</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></div><div class="line">  <span class="keyword">ino_t</span> d_ino;</div><div class="line">  <span class="keyword">char</span> d_name[NAME_MAX + <span class="number">1</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="chdir-fchdir-getcwd-函数"><a href="#chdir-fchdir-getcwd-函数" class="headerlink" title="chdir fchdir getcwd 函数"></a>chdir fchdir getcwd 函数</h2><ul><li>每个进程都有一个当前工作目录</li><li>此目录是搜索相对路径的起点</li><li>当前工作目录是进程的一个属性</li><li>起始目录（口令文件中登录项的一个字段）是登录名的一个属性</li><li>chdir fchdir 函数可以更改当前工作目录</li><li>当前工作目录只影响调用chdir的进城本身，对其他进程不影响</li><li>内核保持有当前工作目录的信息，但只保存指向该目录v节点的指针，并不保存目录名</li><li>getcwd 函数返回当前工作目录的完成路径名</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* 缓冲地址buf 缓冲长度 size */</span></div><div class="line"><span class="comment">/* 缓冲必须有足够长度容纳绝对路径名再加上一个null终止字符 */</span></div></pre></td></tr></table></figure><h2 id="设备特殊文件"><a href="#设备特殊文件" class="headerlink" title="设备特殊文件"></a>设备特殊文件</h2><ul><li>文件系统由主、次设备号表示</li><li>设备号所用的数据类型是 dev_t</li><li>主设备号标识设备驱动程序</li><li>次设备号标识特定的子设备</li><li>同一磁盘驱动上各个文件系统有相同的主设备号，次设备号不同</li><li>宏 major 宏 minor 访问主次设备号</li><li>文件名相关联的 st_dev 值是文件系统的设备号</li><li>只有字符特殊文件和块特殊文件才有 st_rdev 值，此值包含实际设备的设备号</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">major(buf.st_dev);</div><div class="line">minor(buf.st_dev);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;stat-fstat-lstat-函数&quot;&gt;&lt;a href=&quot;#stat-fstat-lstat-函数&quot; class=&quot;headerlink&quot; title=&quot;stat fstat lstat 函数&quot;&gt;&lt;/a&gt;stat fstat lstat 函数&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="unix" scheme="http://luhaozhao.com/categories/unix/"/>
    
    
      <category term="unix" scheme="http://luhaozhao.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>APUE 文件I/O</title>
    <link href="http://luhaozhao.com/2017/09/21/apue-%E6%96%87%E4%BB%B6IO/"/>
    <id>http://luhaozhao.com/2017/09/21/apue-文件IO/</id>
    <published>2017-09-21T16:31:04.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>不带缓冲的I/O unbuffered I/O</li><li>术语不带缓冲指的是每个read 和 write 都调用内核中的一个系统调用</li><li>文件描述符，内核向进程返回</li><li>open create 返回文件描述符</li><li>read write 用文件描述符作为参数</li><li>0 1 2 应该分别由符号常量 STDIN_FILENO STDOUT_FILENO STDERR_FILENO 替换</li><li>这些符号常量定义在头文件 <code>&lt;unistd.h&gt;</code> 中</li><li>文件描述符的变化范围是 0 ~ OPEN_MAX</li></ul><h2 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</div><div class="line"><span class="comment">/* 成功返回文件描述符，失败返回 -1 */</span></div></pre></td></tr></table></figure><p><code>oflag</code> 说明函数的选项，用下列常量进行 <strong>或</strong> 运算构成</p><ul><li>O_RDONLY 只读打开</li><li>O_WRONLY 只写打开</li><li>O_RDWR   读、写打开</li></ul><p>常量定义在头文件 <code>&lt;fcntl.h&gt;</code> 中</p><p>其余可选的选项常量</p><ul><li>O_APPEND 写追加文件尾</li><li>O_CREAT 若文件不存在则创建，需要指定新文件访问权限位的第三个参数 mode</li><li>O_EXCL 如果同时指定 O_CREAT 而文件又存在时，就会出错。使得测试和创建两者成为一个原子操作</li><li>O_TRUNC 如文件存在，且为只写或读写，则长度截短为0</li><li>O_NOCTTY 如果路径是终端设备，则不将该设备分配为进程的控制终端</li><li>O_NONBLOCK 如果路径是 FIFO 块特殊文件 字符特殊文件 则设置为非阻塞模式</li><li>O_DSYNC 使每次write等待物理操作完成，可以不等待文件属性更新</li><li>O_RSYNC 使read操作等待，等待写操作完成才进行read</li><li>O_SYNC 使每次write都等待物理I/O完成，包括文件属性的更新</li></ul><h2 id="creat-函数"><a href="#creat-函数" class="headerlink" title="creat 函数"></a>creat 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="comment">/* 相当于调用 */</span></div><div class="line">open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);</div></pre></td></tr></table></figure><p>早起UNIX无法打开一个尚未存在的文件，因此需要系统调用 creat，现在open函数提供了新选项，也就不再需要creat</p><h2 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"><span class="comment">/* 关闭成功返回0 否则返回 -1 */</span></div></pre></td></tr></table></figure><p>当进程终止时，内核会自动关闭进程打开的所有文件，因此可以不显式调用close关闭打开文件</p><h2 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek 函数"></a>lseek 函数</h2><ul><li>与文件有一个关联的 <strong>当前文件偏移量</strong></li><li>除非指定 O_APPEND 选项，否则打开文件时偏移量设置为0</li><li>调用 lseek 显示设置偏移量</li><li>偏移量大于文件当前长度，下一次写操作将加长该文件，中间构成空洞</li><li>文件空洞不占用磁盘空间，空洞会被读为0</li><li>使用 od 命令可以看到文件的实际内容</li><li>最大文件偏移量根据 off_t 数据类型长度决定，不同实现长度不同</li><li>偏移量仅仅记录在内核中，不引起任何I/O操作</li><li><strong>只修改文件表项中的当前文件偏移量，没进行I/O操作</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> filedes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</div><div class="line"><span class="comment">/* 返回新的偏移量或 -1 */</span></div></pre></td></tr></table></figure><p>whence 的取值</p><ul><li>SEEK_SET 距文件开始处 offset 个字节</li><li>SEEK_CUR 设置为当前值加offset 可正可负</li><li>SEEK_END 设置为文件长度加offet 可正可负</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">off_t</span> currpos;</div><div class="line">currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</div><div class="line"><span class="comment">/* 确定打开文件的当前偏移量 */</span></div></pre></td></tr></table></figure><h3 id="不能对管道、FIFO或套接字-设置偏移量"><a href="#不能对管道、FIFO或套接字-设置偏移量" class="headerlink" title="不能对管道、FIFO或套接字 设置偏移量"></a>不能对管道、FIFO或套接字 设置偏移量</h3><h2 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</div><div class="line"><span class="comment">/* 返回读到的字节数 或到文件尾返回0 或出错返回-1 */</span></div></pre></td></tr></table></figure><ul><li><code>void *</code> 用于表示通用指针</li><li><code>ssize_t</code> 是一个带符号整数</li><li><code>size_t</code> 第三个参数是不带符号整数</li></ul><h2 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</div><div class="line"><span class="comment">/* 返回已写的字节数 或出错返回-1 */</span></div></pre></td></tr></table></figure><p>返回值通常与参数nbytes相同，否则表示出错<br>写出错的原因：</p><ul><li>磁盘写满</li><li>超过一个给定进程的文件长度限制</li></ul><h2 id="I-O的效率"><a href="#I-O的效率" class="headerlink" title="I/O的效率"></a>I/O的效率</h2><p>BUFFsize 设置为文件系统块长度时性能最好，块长由 <code>st_blksize</code> 表示。</p><p>大多数文件系统为改善性能都采用预读 <strong>read ahead</strong> 技术。当检测到正进行顺序读取时，<br>系统企图读入比应用程序所要求的更多数据，并假想应用程序很快就会读这些数据。</p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ul><li>UNIX 支持不同进程之间共享打开的文件。</li><li>内核使用三种数据结构表示打开的文件。</li><li>打开文件描述符表<ul><li>每个进程在进程表中有一个记录项，记录项包含了这张文件描述符表</li><li>也可存放在用户空间，而非进程表中</li><li>描述符表项包含：</li><li>a) 文件描述符标志</li><li>b) 指向文件表项的指针</li></ul></li><li>文件表<ul><li>内核为所有<strong>打开文件</strong>维持一张文件表</li><li>每个进程都有自己的文件表项，使得进程有自己对文件的当前偏移量</li><li>文件表项包含：</li><li>a) 文件状态标志</li><li>b) 当前文件偏移量</li><li>c) 指向 <strong>文件v节点表</strong> 的指针</li></ul></li><li><p>v节点结构</p><ul><li>Linux 没有使用v节点，而是使用通用i节点结构</li><li>每个打开的文件或设备都有一个v节点结构</li><li>一个给定的文件只有一个v节点表项</li><li>v节点包含：</li><li>1) 文件类型</li><li>2) 对此文件进行操作的函数的指针</li><li>3) i节点 i-node 索引节点 （文件所有者 文件长度 文件所在设备 指向文件实际数据块在磁盘上所在位置的指针等）</li></ul></li><li><p>如果使用O_APPEND 标志打开一个文件，则相应标志也被设置到 <em>文件表项</em> 的 <em>文件状态标志</em> 中。</p></li><li><strong>每次</strong> 对具有添写标志的文件执行写操作时，当前文件偏移量首先被设置为 <em>i节点</em> 表项中的文件长度。</li><li><strong>每次写都会设置偏移量</strong></li><li>可能有多个文件描述符项指向同一个文件表项</li><li>当多个进程同写一个文件时，可能会产生预期不到的结果，需要原子操作避免</li></ul><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ul><li>任何一个需要多个函数调用的操作都不可能是原子操作，在函数调用之间，内核可能会临时挂起进程</li><li>设置O_APPEND 标志可以保证每次写之前都会设置偏移量到文件尾端</li><li>对open 函数使用 O_CREAT 和 O_EXCL 选项能保证原子操作</li><li>pread函数 和 pwrite函数 是原子操作 (属于 XSI 扩展)</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</div><div class="line"><span class="comment">/* 相当于原子顺序调用 lseek 和 read */</span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</div><div class="line"><span class="comment">/* 相当于原子顺序调用 lseek 和 write */</span></div></pre></td></tr></table></figure><h2 id="dup函数和dup2函数"><a href="#dup函数和dup2函数" class="headerlink" title="dup函数和dup2函数"></a>dup函数和dup2函数</h2><p>用于复制文件描述符</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"><span class="comment">/* 返回可用描述符 */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">int</span> filedes2)</span></span>;</div><div class="line"><span class="comment">/* 指定新描述符数值 filedes2 */</span></div></pre></td></tr></table></figure><ul><li>如果filedes2已经打开，先将其关闭</li><li>如果filedes 等于 filedes2，则不关闭filedes2 而直接返回 filedes2</li><li>这些函数返回的新描述符与参数 filedes <em>共享</em> 同一个文件表项</li><li>新描述符的执行时关闭 <code>close-on-exec</code> 标志会由dup函数清除（标志被清除表示 该描述符在经过一个exec时仍保持有效）</li><li>复制一个描述符的另一方法是使用 fcntl 函数</li></ul><h2 id="sync-fsync-和-fdatasync-函数"><a href="#sync-fsync-和-fdatasync-函数" class="headerlink" title="sync fsync 和 fdatasync 函数"></a>sync fsync 和 fdatasync 函数</h2><p>延时写 <strong>delayed write</strong><br>输出方式：当数据写入文件时，内核通常先将数据复制到其中一个缓冲区中，<br>如果该缓冲区未写满，则不会将其排入输出队列，<br>等待其写满或内核需要重用该缓冲区（以便存放其他磁盘块数据）时，再讲缓冲排入输出队列，<br>然后等待其到达队首时才进行实际的 I/O 操作。</p><p>延迟写减少了磁盘读写次数，但却降低了文件内容的更新速度，<br>当发生故障时这种延迟写可能造成文件更新内容的丢失，<br><em>为了保证磁盘上实际文件系统与高速缓存中内容的一致性，</em><br>UNIX 系统提供了 sync fsync 和 fdatasync 三个函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure><ul><li>sync函数不等待实际写磁盘操作结束，只将修改过的块缓冲排入写队列</li><li>命令 sync 也调用sync函数</li><li>系统守护进程会周期调用 sync函数，保证定期冲洗内核的块缓冲区</li><li>fsync 对指定的描述符起作用，等待写磁盘操作完成，包括数据部分和更新文件属性</li><li>fdatasync 类似fsync 但只影响文件的数据部分</li></ul><h2 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h2><p>可以改变已打开的文件的性质</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fidedes, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>;</div></pre></td></tr></table></figure><p>作用：</p><ul><li>复制一个现有的描述符 cmd=F_DUPFD</li><li>获得或设置 文件描述符标记 cmd=F_GETFD 或 F_SETFD</li><li>获得或设置 文件状态标志 cmd=F_GETFL 或 F_SETFL<ul><li>三个访问方式标志 O_RDONLY O_WRONLY O_RDWR 并不各占1位，因此首先要用屏蔽字 O_ACCMODE 取得访问模式位，然后将结果进行比较</li><li>可以设置的几个标志是 O_APPEND O_NONBLOCK O_SYNC O_DSYNC O_RSYNC O_FSYNC O_ASYNC</li></ul></li><li>获得或设置 异步I/O所有权 cmd=F_GETOWN 或 F_SETOWN<ul><li>取得当前接收 SIGIO 和 SIGURG 信号的进程ID或进程组ID</li></ul></li><li>获得或设置 记录锁 cmd=F_GETLK F_SETLK 或 F_SETLKW</li></ul><p>该函数的返回值与命令有关，如果出错所有命令都返回 -1</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span></div><div class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span>   val;</div><div class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</div><div class="line">    err_quit(<span class="string">"usage: a.out &lt;descriptor#&gt;"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((val = fcntl(atoi(argv[<span class="number">1</span>]), F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">    err_sys(<span class="string">"fcntl error for fd %d"</span>, atoi(argv[<span class="number">1</span>]));</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (val &amp; O_ACCMODE) &#123;</div><div class="line">  <span class="keyword">case</span> O_RDONLY:</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"read only"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> O_WRONLY:</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"write only"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> O_RDWR:</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"read write"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    err_dump(<span class="string">"unknown access mode"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (val &amp; O_APPEND)</div><div class="line">    <span class="built_in">printf</span>(<span class="string">", append"</span>);</div><div class="line">  <span class="keyword">if</span> (val &amp; O_NONBLOCK)</div><div class="line">    <span class="built_in">printf</span>(<span class="string">", nonblocking"</span>);</div><div class="line">  <span class="keyword">if</span> (val &amp; O_SYNC)</div><div class="line">    <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC)</span></div><div class="line">  <span class="keyword">if</span> (val &amp; O_FSYNC)</div><div class="line">    <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">  <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>修改文件状态标志时要先取得现有标志值，然后根据需要修改，最后设置新标志值:</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span></div><div class="line">set_fl(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags) <span class="comment">/* flags are file status flags to turn on */</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span>   val;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">    err_sys(<span class="string">"fcntl F_GETFL error"</span>);</div><div class="line"></div><div class="line">  val |= flags;   <span class="comment">/* turn on flags */</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</div><div class="line">    err_sys(<span class="string">"fcntl F_SETFL error"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span></div><div class="line">clr_fl(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags) <span class="comment">/* flags are file status flags to turn on */</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span>   val;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">    err_sys(<span class="string">"fcntl F_GETFL error"</span>);</div><div class="line"></div><div class="line">  val &amp;= ~flags;   <span class="comment">/* turn off flags */</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</div><div class="line">    err_sys(<span class="string">"fcntl F_SETFL error"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用打开 O_SYNC 使得每次write都要等待，直至数据写到磁盘上再返回，数据库系统很可能需要使用O_SYNC</p><ul><li>fsync和fdatasync 在我们需要时更新文件内容</li><li>O_SYNC 标志则在我们每次写至文件时更新文件内容</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">set_fl(STDOUT_FILENO, O_SYNC);</div></pre></td></tr></table></figure><h2 id="dev-fd-目录"><a href="#dev-fd-目录" class="headerlink" title="/dev/fd 目录"></a>/dev/fd 目录</h2><p>打开文件 <code>/dev/fd/n</code> 等效于复制描述符n (假定n是打开的)</p><p>使用/dev/fd 提高文件名参数的一致性，也更加清晰，无需使用 <code>-</code> 这种需要特殊解释的文件名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不带缓冲的I/O unbuffered I/O&lt;/li&gt;
&lt;li&gt;术语不带缓冲指的是每个read 和 write
      
    
    </summary>
    
      <category term="unix" scheme="http://luhaozhao.com/categories/unix/"/>
    
    
      <category term="unix" scheme="http://luhaozhao.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>APUE 基础知识</title>
    <link href="http://luhaozhao.com/2017/09/20/apue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://luhaozhao.com/2017/09/20/apue-基础知识/</id>
    <published>2017-09-20T14:53:58.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UNIX-体系结构"><a href="#UNIX-体系结构" class="headerlink" title="UNIX 体系结构"></a>UNIX 体系结构</h2><ul><li>硬件资源</li><li>内核</li><li>系统调用 <strong>内核的接口</strong></li><li>公用函数库 构建在系统调用接口之上</li><li>shell 一种特殊的应用程序，为其他应用程序提供一个接口</li><li>应用程序 可使用公用函数库，也可使用系统调用</li></ul><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>常见shell</p><ul><li><code>/bin/sh</code></li><li><code>/bin/bash</code></li><li><code>/bin/csh</code></li><li><code>/bin/ksh</code></li><li><code>/bin/tcsh</code></li></ul><p>系统从口令文件 <code>/etc/passwd</code> 对应用户最后一个字段了解到应该执行哪个shell</p><h3 id="交互式shell-versus-非交互式shell"><a href="#交互式shell-versus-非交互式shell" class="headerlink" title="交互式shell versus 非交互式shell"></a><strong>交互式shell</strong> versus <strong>非交互式shell</strong></h3><ul><li>交互模式 就是在终端上执行，等待你的输入，并且立即执行你提交的命令</li><li>非交互模式 以shell script 方式执行</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">echo</span> $- <span class="comment"># 打印当前shell的选项标志 i 即表示 interactive shell</span></div></pre></td></tr></table></figure><h3 id="登录shell-VS-非登录shell"><a href="#登录shell-VS-非登录shell" class="headerlink" title="登录shell VS 非登录shell"></a>登录shell VS 非登录shell</h3><ul><li>登录shell 需要用户名、密码登录后才能进入的shell 或通过 <code>bash --login</code> 生成的shell<ul><li><code>echo $0</code> 进程名是 <code>-bash</code></li><li>读取配置 <code>/etc/profile</code> &gt; (<code>~/.bash_profile</code> || <code>~/.bash_login</code> || <code>~/.profile</code>)</li></ul></li><li>非登录shell 打开终端窗口程序是一个非登录shell, 直接使用命令 <code>bash</code> 打开一个 非登录shell<ul><li><code>echo $0</code> 进程名是 <code>bash</code></li><li>读取配置 <code>~/.bashrc</code></li></ul></li></ul><p>退出登出</p><ul><li>exit 退出一个shell 登录shell 或 非登录shell</li><li>logout 登出登录shell 不能退出非登录shell</li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><ul><li>文件名不能出现斜线 <code>/</code> 和 空操作符 <code>null</code></li><li>目录是一个包含许多目录项的文件</li><li>创建新目录时自动创建两个文件名 <code>.</code> 和 <code>..</code> 点指向当前目录，点点指向父目录</li><li>根目录点和点点相同</li><li>每个进程都有一个当前工作目录 <code>cwd</code> 所有<strong>相对路径名</strong>都从 <code>cwd</code> 开始解释</li><li>进程可以用 <code>chdir</code> 函数更改 <code>cwd</code></li><li>起始目录 <code>home directory</code> 从口令文件中得到 登录时 <code>cwd</code> 会设置为起始目录</li></ul><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><ul><li>文件描述符，当内核打开一个已有文件或创建一个新文件时返回一个 <code>file descriptor</code></li><li>每运行一个新程序，所有shell都为它打开三个文件描述符 <code>STDIN_FILENO</code> <code>STDOUT_FILENO</code> <code>STDERR_FILENO</code></li><li>不做重定向处理，默认三个文件描述符都链向终端</li></ul><h3 id="不带缓冲的-I-O"><a href="#不带缓冲的-I-O" class="headerlink" title="不带缓冲的 I/O"></a>不带缓冲的 I/O</h3><ul><li>open</li><li>read</li><li>write</li><li>lseek</li><li>close</li></ul><p>以上函数都使用文件描述符，<strong>不带缓冲</strong></p><h3 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O"></a>标准 I/O</h3><p><strong>标准I/O函数</strong> 提供了一种对 <strong>不带缓冲I/O函数</strong> 的带缓冲的接口</p><p><code>&lt;stdio.h&gt;</code> 包含了所有标准I/O函数的原型</p><p>优点：</p><ul><li>无需担心如何选取最优的缓冲区大小</li><li>简化对输入行的处理，直接读取一整行而不像 <code>read</code> 指定字节数</li></ul><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><ul><li>程序，是存放在磁盘上、处于某个目录中的一个<strong>可执行文件</strong></li><li>通过exec函数，由内核读入存储器，并执行</li><li>进程，程序的执行实例</li><li>每个进程都有一个唯一的进程ID</li></ul><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul><li>fork 创建一个新进程，它由父进程调用一次，但返回两次（分别在父进程和子进程中）</li><li>execlp 执行从标准输入读入的命令，用新的程序文件 <strong>替换</strong> 了原先执行的程序文件</li><li>fork + exec 的组合是某些操作系统所称的 <strong>spawn</strong> 一个新进程，在UNIX 中这两部分相互分隔，构成两个函数</li><li>waitpid 等待子进程终止，返回终止状态</li></ul><h3 id="线程和线程ID"><a href="#线程和线程ID" class="headerlink" title="线程和线程ID"></a>线程和线程ID</h3><ul><li>同一进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性</li><li>线程ID只在它所属的进程内起作用</li><li>线程模型在进程模型建立很久后才被引入到UNIX</li></ul><h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><ul><li>errno 通常被设置为含有附加信息的一个值，指示出错原因</li><li>某些函数不返回负值，而是使用另一个约定，返回Null指针</li><li>如果没有出错，errno的值也不会被清除，因此应在函数返回指名出错时才去验证它的值</li><li>任何函数都不会将errno的值设置为0，在头文件中定义的所有常量都不为0</li></ul><p>头文件 <code>&lt;errno.h&gt;</code> 定义了符号errno以及可以赋予它的各种常量，常量以 <code>E</code> 开头。</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</div><div class="line"><span class="comment">/* 将errnum 通常是errno值 映射为一个出错信息字符串，并返回此字符串的指针 */</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</div><div class="line"><span class="comment">/* 基于errno的当前值在标准出错上产生一条出错信息 */</span></div></pre></td></tr></table></figure><h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><ul><li>用户ID</li><li>组ID</li><li>每个文件都存放所有者的用户ID和组ID</li><li>存放数值比存放字符串节省空间</li><li>附加组ID 一个用户可属于多至16个附加组</li></ul><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>进程处理信号的三种选择</p><ul><li>忽略该信号</li><li>按系统默认方式处理</li><li>提供一个函数，捕捉该信号，signal函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">signal(SIGINT, sig_int);</div><div class="line"><span class="comment">/* 注册函数 */</span></div></pre></td></tr></table></figure><p>产生信号</p><ul><li>终端键盘上的中断键 Delete键或Ctrl+C</li><li>终端键盘上的退出键 Ctrl+\</li><li>kill函数发送信号</li><li>kill限制：必须是该进程的所有者或超级用户</li></ul><h2 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h2><ul><li>日历时间 时间戳<ul><li>系统基本数据类型 <code>time_t</code> 保存这种时间值</li></ul></li><li>进程时间 也称为CPU时间<ul><li>用以度量进程使用CPU资源，以时钟滴答计数</li><li>系统基本数据类型 <code>clock_t</code> 保存这种时间值</li><li>函数 <code>sysconf</code> 得到每秒时钟滴答数</li></ul></li></ul><p>度量一个进程的执行时间</p><ul><li>时钟时间 又称为 <strong>墙上时钟时间</strong> 进程运行的时间总量，其值与系统中同时运行的进程数有关</li><li>用户CPU时间，执行用户指令所用时间</li><li>系统CPU时间，为该进程执行内核程序所经历的时间</li><li>CPU时间 = 用户CPU时间 + 系统CPU时间</li></ul><h2 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h2><ul><li>从实现者角度，系统调用和库函数之间有重大区别</li><li>从用户角度看，区别并不重要</li><li>系统调用和库函数都以C函数的形式出现，两者都为应用程序提供服务</li><li>系统调用提供一种最小接口</li><li>库函数通常提供比较复杂的功能</li><li>系统调用指最底层的一个调用，面向硬件；库函数调用面向应用开发</li><li>系统调用是操作系统相关的，一般没有跨平台的可移植性</li><li>应用程序可以调用系统调用或库函数，而很多库函数则会调用系统调用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UNIX-体系结构&quot;&gt;&lt;a href=&quot;#UNIX-体系结构&quot; class=&quot;headerlink&quot; title=&quot;UNIX 体系结构&quot;&gt;&lt;/a&gt;UNIX 体系结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;硬件资源&lt;/li&gt;
&lt;li&gt;内核&lt;/li&gt;
&lt;li&gt;系统调用 &lt;stro
      
    
    </summary>
    
      <category term="unix" scheme="http://luhaozhao.com/categories/unix/"/>
    
    
      <category term="unix" scheme="http://luhaozhao.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>Shell 脚本编程</title>
    <link href="http://luhaozhao.com/2017/08/30/shellscript/"/>
    <id>http://luhaozhao.com/2017/08/30/shellscript/</id>
    <published>2017-08-30T15:44:31.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td><code>$?</code></td><td>上一个命令的退出状态</td></tr><tr><td><code>$$</code></td><td>当前shell进程ID</td></tr><tr><td><code>$0</code></td><td>在函数中表示函数名</td></tr><tr><td><code>$1</code> <code>$2</code> … <code>${10}</code></td><td>调用函数时传递的变量 注意花括号包围</td></tr><tr><td><code>$#</code></td><td>命令行参数个数</td></tr><tr><td><code>$*</code> <code>$@</code></td><td>全部展开成列表</td></tr><tr><td><code>&quot;$*&quot;</code></td><td>变量 <code>IFS</code> 分隔开位置参数的<strong>字符串</strong> <em>一个整体</em></td></tr><tr><td><code>&quot;$@&quot;</code></td><td><strong>位置参数列表</strong> “$1” “$2” … “$n”</td></tr></tbody></table><p>示例</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ubuntu@ubuntu-xenial:~$ ./demo <span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c and d"</span></div><div class="line">$*= a b c and d</div><div class="line"><span class="string">"$*"</span>= a b c and d</div><div class="line"><span class="variable">$@</span>= a b c and d</div><div class="line"><span class="string">"<span class="variable">$@</span>"</span>= a b c and d</div><div class="line"><span class="built_in">print</span> each param from $*</div><div class="line">a</div><div class="line">b</div><div class="line">c</div><div class="line">and</div><div class="line">d</div><div class="line"><span class="built_in">print</span> each param from <span class="variable">$@</span></div><div class="line">a</div><div class="line">b</div><div class="line">c</div><div class="line">and</div><div class="line">d</div><div class="line"><span class="built_in">print</span> each param from <span class="string">"$*"</span></div><div class="line">a b c and d</div><div class="line"><span class="built_in">print</span> each param from <span class="string">"<span class="variable">$@</span>"</span></div><div class="line">a</div><div class="line">b</div><div class="line">c and d</div></pre></td></tr></table></figure><h2 id="shell参数替换"><a href="#shell参数替换" class="headerlink" title="shell参数替换"></a>shell参数替换</h2><h3 id="模式替换"><a href="#模式替换" class="headerlink" title="模式替换"></a>模式替换</h3><table><thead><tr><th>模式替换</th><th>描述</th></tr></thead><tbody><tr><td><code>${var/pattern/string}</code></td><td>替换一次</td></tr><tr><td><code>${var//pattern/string}</code></td><td>全部替换</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">var = hello1 world1 hello2 world2</div><div class="line"><span class="variable">$&#123;var/hello/olleh&#125;</span> <span class="comment"># =&gt; olleh1 world1 hello2 world2</span></div><div class="line"><span class="variable">$&#123;var//hello/olleh&#125;</span> <span class="comment"># =&gt; olleh1 world1 olleh2 world2</span></div></pre></td></tr></table></figure><h3 id="模式删除"><a href="#模式删除" class="headerlink" title="模式删除"></a>模式删除</h3><table><thead><tr><th>模式删除</th><th>描述</th></tr></thead><tbody><tr><td><code>${var#pattern}</code></td><td>从开头删除最小匹配的子串</td></tr><tr><td><code>${var##pattern}</code></td><td>从开头删除最大匹配子串</td></tr><tr><td><code>${var%pattern}</code></td><td>从结尾删除最小匹配子串</td></tr><tr><td><code>${var%%pattern}</code></td><td>从结尾删除最大匹配子串</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">var1 = abcd12345abc6789</div><div class="line">Number of characters <span class="keyword">in</span> abcd12345abc6789 = 16</div><div class="line"></div><div class="line">pattern1 = a*c</div><div class="line"><span class="variable">$&#123;var1#$pattern1&#125;</span> <span class="comment"># =&gt; d12345abc6789</span></div><div class="line"><span class="variable">$&#123;var1##$pattern1&#125;</span> <span class="comment"># =&gt; 6789</span></div><div class="line"></div><div class="line">pattern2 = b*9</div><div class="line"><span class="variable">$&#123;var1%pattern2&#125;</span> <span class="comment"># =&gt; abcd12345a</span></div><div class="line"><span class="variable">$&#123;var1%%pattern2&#125;</span> <span class="comment"># =&gt; a</span></div></pre></td></tr></table></figure><h3 id="字符数计算"><a href="#字符数计算" class="headerlink" title="字符数计算"></a>字符数计算</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 返回变量var的字符串长度</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></div></pre></td></tr></table></figure><h2 id="带冒号的参数替换"><a href="#带冒号的参数替换" class="headerlink" title="带冒号的参数替换"></a>带冒号的参数替换</h2><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="variable">$&#123;var:-word&#125;</span> <span class="comment"># 如果var未设置，则整个参数替换表达式值为word</span></div><div class="line"><span class="variable">$&#123;var:+word&#125;</span> <span class="comment"># 如果var设置了，则整个表达式的值为word</span></div><div class="line"><span class="variable">$&#123;var:=word&#125;</span> <span class="comment"># 如果var未设置，则表达式值为word，变量var的值同时也设为word</span></div><div class="line"><span class="variable">$&#123;var:?word&#125;</span> <span class="comment"># 如果var未设置则打印错误，如果有设置则表达式值为var原来的值</span></div><div class="line"><span class="variable">$&#123;var:offset:length&#125;</span> <span class="comment"># var变量切片，生成子串</span></div><div class="line">string=abcdefghijklmn...</div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:4&#125;</span> <span class="comment"># =&gt; efghi...</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:4:8&#125;</span> <span class="comment"># =&gt; efghijkl</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:(-2):2&#125;</span> <span class="comment"># =&gt; yz</span></div></pre></td></tr></table></figure><h2 id="变量展开"><a href="#变量展开" class="headerlink" title="变量展开"></a>变量展开</h2><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">var=<span class="string">"hello world"</span></div><div class="line"><span class="variable">$var</span> <span class="comment"># 等价 $&#123;var&#125;</span></div><div class="line"><span class="variable">$&#123;var&#125;</span> <span class="comment"># 等价 $var</span></div><div class="line"><span class="string">"<span class="variable">$var</span>"</span> <span class="comment"># 可以放在双引号中</span></div><div class="line"></div><div class="line"><span class="variable">$&#123;#var&#125;</span> <span class="comment"># 获得字符串长度</span></div><div class="line"><span class="variable">$&#123;var:+exp&#125;</span> <span class="comment"># 如果变量var有值且不为空，则使用exp的值</span></div><div class="line"><span class="variable">$&#123;var:+'HELLO WORLD'&#125;</span> <span class="comment"># 返回"HELLO WORLD"</span></div><div class="line"></div><div class="line">num1=1</div><div class="line">num2=2</div><div class="line">$[ num1 + num2 ] <span class="comment"># [ ] 操作符用于计算，类似let命令不需要使用$</span></div><div class="line">$[ <span class="variable">$num1</span> + <span class="variable">$num2</span> ] <span class="comment"># 或者使用$也是可以的</span></div><div class="line">$((num1 + num2)) <span class="comment"># $(()) 操作符</span></div><div class="line">$((<span class="variable">$num1</span> + <span class="variable">$num2</span>)) <span class="comment"># 变量前$不是必需的</span></div><div class="line"></div><div class="line"><span class="comment"># 子 shell</span></div><div class="line">result=$(expr 1 + 1) <span class="comment"># $()</span></div><div class="line">result=`expr 1 + 1` <span class="comment"># 子 shell 的另一种写法</span></div><div class="line"></div><div class="line"><span class="comment"># 把子 shell 放入双引号中，会保留空格和换行符</span></div><div class="line">out=<span class="string">"<span class="variable">$(cat file)</span>"</span></div><div class="line"></div><div class="line">array=(1 2 3 4 5) <span class="comment"># 定义数组</span></div><div class="line"><span class="variable">$&#123;array[$index]&#125;</span> <span class="comment"># 数组索引取值，从 0 开始索引</span></div><div class="line"><span class="variable">$&#123;!array[*]&#125;</span> <span class="comment"># 关联数组的键列表</span></div><div class="line"><span class="variable">$&#123;!array[@]&#125;</span> <span class="comment"># 等价 ⬆️</span></div><div class="line"><span class="variable">$&#123;array[*]&#125;</span> <span class="comment"># 获取关联数组的值列表</span></div><div class="line"><span class="variable">$&#123;#array[*]&#125;</span> <span class="comment"># 数组长度</span></div></pre></td></tr></table></figure><h2 id="shift命令"><a href="#shift命令" class="headerlink" title="shift命令"></a>shift命令</h2><p>提升位置参数</p><p>所有的位置参数向左 <code>shift</code> 掉一个，<code>shift</code> 出队列，<code>$#</code> 减1，<code>$0</code> 不变，<code>$1</code> 的值变成 <code>$2</code> 的值</p><h2 id="fork-bomb"><a href="#fork-bomb" class="headerlink" title="fork_bomb"></a>fork_bomb</h2><ul><li><strong>Fork BOMB</strong> <code>:() { :|:&amp; };:</code></li><li>常量通常用大写字母表示，变量通常用小写字母表示。</li><li><code>true</code>是作为<code>/bin</code>中一个二进制文件来实现的，使用shell 内建的<code>:</code>命令，它总返回为<code>0</code>的退出码，更快。</li><li>运行命令知道执行成功的函数</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="title">repeat</span></span> () &#123; <span class="keyword">while</span> :; <span class="keyword">do</span> <span class="variable">$@</span> &amp;&amp; <span class="built_in">return</span>; sleep 5; <span class="keyword">done</span> &#125;</div></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>shell函数是位于其他脚本中的微脚本，定义<code>shell函数</code><strong>两种语法</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">function</span> name &#123;</div><div class="line">  commands</div><div class="line">  <span class="built_in">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 函数名和括号之间有空格</span></div><div class="line"><span class="function"><span class="title">name</span></span> () &#123;</div><div class="line">  <span class="built_in">local</span> foo <span class="comment"># 定义局部变量用local</span></div><div class="line">  foo=1</div><div class="line">  commands</div><div class="line">  <span class="built_in">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>函数定义时需要圆括号，<strong>但如果没实参，则调用时不能带上括号</strong>。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> [ <span class="variable">$x</span> = 5 ]; <span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'yes'</span></div><div class="line"><span class="keyword">elif</span> commands; <span class="keyword">then</span></div><div class="line">    commands...</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'no'</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure><ul><li>条件判断相等单双等号都可以，<strong>等号两边有空格</strong>。</li><li>函数和脚本执行完毕会发送给系统一个<code>退出状态</code>，这个值从0-255，<strong>0表示成功</strong>，其他都是失败。</li><li><code>$?</code> 该参数用来检查上一个命令的退出状态。</li><li><code>if</code> 语句做的事情其实就是<strong>计算命令执行成功或失败</strong>，即计算<code>$?</code>是否为<code>0</code>！！！</li><li>脚本中末尾可以使用 <code>exit</code> 命令，接收可选退出状态数作为参数，表示脚本的退出状态。</li><li>遇到 <code>exit</code>，脚本执行就会结束返回。</li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="循环while-until"><a href="#循环while-until" class="headerlink" title="循环while/until"></a>循环while/until</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> commands; <span class="keyword">do</span></div><div class="line">  xxx</div><div class="line"><span class="keyword">done</span></div><div class="line"><span class="built_in">break</span> 跳出循环</div><div class="line"><span class="built_in">continue</span> 执行下一次循环</div><div class="line"></div><div class="line">until [ xxx ]; <span class="keyword">do</span></div><div class="line">  xxx</div><div class="line"><span class="keyword">done</span> &lt; foo.txt</div><div class="line"></div><div class="line">foo.txt | <span class="keyword">while</span> <span class="built_in">read</span> var; <span class="keyword">do</span></div><div class="line">  xxx</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><h3 id="流程控制case"><a href="#流程控制case" class="headerlink" title="流程控制case"></a>流程控制case</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="variable">$REPLY</span> <span class="keyword">in</span></div><div class="line">  0) commands1 ;;</div><div class="line">  1) commands2 ;;</div><div class="line">  a|A) <span class="built_in">echo</span> “可以使用竖线字符作为分隔符把多个模式结合起来，或条件<span class="string">"</span></div><div class="line"><span class="string">    ;;</span></div><div class="line"><span class="string">  [[:alpha:]]) xxx ;;</span></div><div class="line"><span class="string">  *) default ;;</span></div><div class="line"><span class="string">esac</span></div></pre></td></tr></table></figure><p>添加 <code>;;&amp;</code> 语法允许 <code>case</code> 语句继续执行下一条测试而不是简单终止运行。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>花括号展开</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;A..D&#125;; <span class="keyword">do</span></div><div class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><p>路径名展开</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> foo*.txt; <span class="keyword">do</span></div><div class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><p>命令替换</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(strings file); <span class="keyword">do</span></div><div class="line">  len=$(<span class="built_in">echo</span> <span class="variable">$i</span> | wc -c)</div><div class="line">  xxx</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><p>strings 能为文件生成一个可读的文本格式的words列表，用于for循环</p><p>C语言格式</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (( i=0; i&lt;5; i=i+1 )); <span class="keyword">do</span></div><div class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>[ expression ]</code> 与 <code>test expression</code> 是等价的。</p><h3 id="算术比较"><a href="#算术比较" class="headerlink" title="算术比较"></a>算术比较</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[ <span class="variable">$var</span> -eq 0 ]</div><div class="line">[ <span class="variable">$var</span> -ne 0 ]</div><div class="line">[ <span class="variable">$var1</span> -ne 0 -a <span class="variable">$var2</span> -gt 2 ] <span class="comment"># 逻辑与 -a 逻辑或 -o</span></div></pre></td></tr></table></figure><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>等于</td></tr><tr><td><code>-ne</code></td><td>不等于</td></tr><tr><td><code>-gt</code></td><td>大于</td></tr><tr><td><code>-lt</code></td><td>小于</td></tr><tr><td><code>-ge</code></td><td>大于等于</td></tr><tr><td><code>-le</code></td><td>小于等于</td></tr></tbody></table><h3 id="文件系统相关测试"><a href="#文件系统相关测试" class="headerlink" title="文件系统相关测试"></a>文件系统相关测试</h3><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td><code>-f</code></td><td>正常的文件路径或文件名</td></tr><tr><td><code>-e</code></td><td>文件存在</td></tr><tr><td><code>-x</code></td><td>文件可执行</td></tr><tr><td><code>-d</code></td><td>判断目录</td></tr><tr><td><code>-c</code></td><td>判断字符设备文件</td></tr><tr><td><code>-b</code></td><td>块设备文件</td></tr><tr><td><code>-w</code></td><td>文件可写</td></tr><tr><td><code>-r</code></td><td>文件可读</td></tr><tr><td><code>-L</code></td><td>是一个符号链接</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">fpath=<span class="string">"/etc/passwd"</span></div><div class="line"><span class="keyword">if</span> [ -e <span class="variable">$fpath</span> ]; <span class="keyword">then</span></div><div class="line">  <span class="built_in">echo</span> file exists;</div><div class="line"><span class="keyword">else</span></div><div class="line">  <span class="built_in">echo</span> does not exists;</div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure><h3 id="测试字符串表达式"><a href="#测试字符串表达式" class="headerlink" title="测试字符串表达式"></a>测试字符串表达式</h3><p>最好使用双中括号<code>[[ ]]</code></p><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td><code>-z</code></td><td>空字符串</td></tr><tr><td><code>-n</code></td><td>非空字符串</td></tr></tbody></table><p><code>[[ ]]</code> 命令是更现代的测试版本，支持正则匹配 <code>=~</code> 支持路径名展开 <code>==</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> [[ <span class="variable">$FILE</span> == foo.* ]]; <span class="keyword">then</span></div></pre></td></tr></table></figure><p><code>(( ))</code> 用来执行算术真测试，<strong>如果算术结果非零，算术真测试为真</strong>。<br>在双括号内只处理整数，因此能通过名字识别出变量而不需要展开操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (( (( INT % 2 )) == 0 )); <span class="keyword">then</span></div></pre></td></tr></table></figure><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><ul><li><code>AND</code> <code>-a</code> <code>&amp;&amp;</code></li><li><code>OR</code> <code>-o</code> <code>||</code></li><li><code>NOT</code> <code>!</code></li></ul><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>读取键盘输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">read</span> int</div><div class="line"><span class="built_in">read</span> var1 var2 var3</div><div class="line"></div><div class="line"><span class="built_in">read</span> -a array <span class="comment">#输入赋值到数组array中</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -n 5 <span class="comment"># 只读取5个输入字符</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -p <span class="string">"提示输入"</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -s <span class="comment"># 输入密码使用的静默输入</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -r <span class="comment"># 反斜杠不解释为转义字符</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -e <span class="comment"># 使用Readline的方式编辑输入</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -u <span class="built_in">fg</span> <span class="comment"># 使用文件描述符输入，不是标准输入</span></div><div class="line"></div><div class="line">IFS=<span class="string">":"</span> <span class="built_in">read</span> user pw id god name home shell &lt;&lt;&lt; <span class="string">"<span class="variable">$file_info</span>"</span></div><div class="line"><span class="comment"># 临时改变环境变量赋值</span></div><div class="line">&lt;&lt;&lt; <span class="comment"># 操作符指示一个here字符串</span></div></pre></td></tr></table></figure><p>这里不能使用管道的原因是管道线会创建子shell，子shell永远不能改变父进程的环境，当子shell退出，子shell做的改变在父进程里都看不到。</p><ul><li>利用 <code>source</code> 来执行脚本是在父进程中执行的。</li><li>点号执行，直接执行，或sh执行会创建子进程执行。</li></ul><h2 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h2><table><thead><tr><th>执行脚本时添加选项</th><th>作用</th></tr></thead><tbody><tr><td><code>n</code></td><td>不执行，只检查语法</td></tr><tr><td><code>v</code></td><td>执行前打印脚本内容</td></tr><tr><td><code>x</code></td><td>跟踪命令展开</td></tr></tbody></table><p>可以对脚本中部分区域进行追踪而不是整个脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">command1</div><div class="line"><span class="built_in">set</span> -x  <span class="comment"># 开始追踪</span></div><div class="line">command2</div><div class="line"><span class="built_in">set</span> +x  <span class="comment"># 关闭追踪</span></div><div class="line">command3</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;特殊变量&quot;&gt;&lt;a href=&quot;#特殊变量&quot; class=&quot;headerlink&quot; title=&quot;特殊变量&quot;&gt;&lt;/a&gt;特殊变量&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbod
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://luhaozhao.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>《理解Unix进程》笔记</title>
    <link href="http://luhaozhao.com/2017/08/25/ruby-process/"/>
    <id>http://luhaozhao.com/2017/08/25/ruby-process/</id>
    <published>2017-08-25T12:00:21.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>Unix系统组成：用户空间<code>userland</code>与内核<code>kernel</code>。</li><li>内核是处在硬件之上的层，内核管理硬件，但程序不可直接访问内核，而是通过<strong>系统调用</strong>来进行通信。</li></ol><h2 id="进程都有进程指示符pid"><a href="#进程都有进程指示符pid" class="headerlink" title="进程都有进程指示符pid"></a>进程都有进程指示符<code>pid</code></h2><p>内核把所有的进程都看成数字，这个数字就是进程指示符。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">puts Process.pid  <span class="comment">#在irb中执行，打印当前irb进程的进程ID</span></div></pre></td></tr></table></figure><p>Ruby的<code>Process.pid</code>封装了<strong>系统调用</strong><code>getpid</code>，Ruby也有一个全局变量<code>$$</code>保存了当前进程的指示符。</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ ps -p &lt;pid-of-irb-process&gt;</div><div class="line"><span class="comment"># 在命令行中执行，替换pid，打印刚才的irb进程</span></div></pre></td></tr></table></figure><h2 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h2><p>系统中运行的每一个进程都有<strong>父进程</strong>。父进程标识符<code>ppid</code>。<br>大多数情况下，进程A的父进程就是调用A进程的进程。比如，<code>iTerm</code>进程是<code>zsh</code>进程的<strong>父进程</strong>，在zsh中执行<code>ls</code>命令，<code>ls</code>进程的<strong>父进程</strong>就是<code>zsh</code>进程。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">puts Process.ppid <span class="comment"># 打印当前进程的父进程id</span></div></pre></td></tr></table></figure><p>Ruby的<code>Process.ppid</code>是对应系统调用<code>getppid</code>。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p><strong>文件描述符代表打开的文件</strong>。</p><p>在一个进程中打开一个文件（设备，管道，socket等）就会分配一个文件描述符，文件描述符在不相关的进程间<strong>不会共享</strong>，进程退出后，进程中的资源文件就会关闭。</p><p>在Ruby中，<code>IO</code>类描述了打开的资源。任意一个IO对象都有一个相关联的<strong>文件描述符编号</strong>，可以使用<code>IO#fileno</code>进行访问。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">passwd = File.open(<span class="string">'/etc/passwd'</span>)</div><div class="line">puts passwd.fileno</div></pre></td></tr></table></figure><p><code>内核</code>通过唯一的数字标识<strong>跟踪</strong><code>进程</code>所用的<strong>资源</strong>。只是用来跟踪打开的资源，已关闭资源没有文件描述符。</p><ol><li>文件描述符优先分配最小可用的整数，</li><li>如果之前打开的文件关闭了，那么这个文件占用的描述符就会空出来随时准备分配。</li></ol><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 当尝试读取一个关闭的文件的描述符时，会引发异常</span></div><div class="line">passwd = File.open(<span class="string">'/etc/passwd'</span>)</div><div class="line">passwd.close</div><div class="line">puts passwd.fileno    <span class="comment">#IOError: closed stream</span></div></pre></td></tr></table></figure><h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>每个unix进程都分配3个打开的资源：</p><ol><li><strong>STDIN</strong> <code>0</code> 标准输入</li><li><strong>STDOUT</strong> <code>1</code> 标准输出</li><li><strong>STDERR</strong> <code>2</code> 标准错误</li></ol><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">puts STDIN.fileno</div><div class="line">puts STDOUT.fileno</div><div class="line">puts STDERR.fileno</div></pre></td></tr></table></figure><blockquote><p>对应的系统调用指令有<code>open close read write pipe fsync stat</code></p><p>可以通过<code>man</code>指令获得详细文档 <code>man 2 open</code></p></blockquote><h2 id="进程有资源限制"><a href="#进程有资源限制" class="headerlink" title="进程有资源限制"></a>进程有资源限制</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">p Process.getrlimit(<span class="symbol">:NOFILE</span>)</div><div class="line"><span class="comment"># 返回一个二元数组，比如[1024, 4096]</span></div></pre></td></tr></table></figure><h3 id="软限制soft-limit"><a href="#软限制soft-limit" class="headerlink" title="软限制soft limit"></a>软限制<code>soft limit</code></h3><blockquote><p>软限制并不是真正的限制，当进程打开文件超过软限制时会引发异常<strong>Error::EMFILE</strong>，但你可以更改这个限制。</p></blockquote><p><strong>使用场景</strong>：httperf进程需要创建5000个网络连接，这个时候就需要修改<code>soft limit</code>。或者使用第三方代码库需要限制它打开的资源。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 把限制都设成4096 =&gt; [4096, 4096]</span></div><div class="line">Process.setrlimit(<span class="symbol">:NOFILE</span>, <span class="number">4096</span>)</div><div class="line"></div><div class="line"><span class="comment"># 把软限制提高到硬限制水平</span></div><div class="line">Process.setrlimit(<span class="symbol">:NOFILE</span>, Process.getrlimit(<span class="symbol">:NOFILE</span>)[<span class="number">1</span>])</div></pre></td></tr></table></figure><h3 id="硬限制hard-limit"><a href="#硬限制hard-limit" class="headerlink" title="硬限制hard limit"></a>硬限制<code>hard limit</code></h3><blockquote><p>硬限制只能通过超级用户修改，有兴趣的可以参考<code>$man 8 sysctl</code>。</p></blockquote><p>注意设置hard limit的过程是不可逆的，设低了就不能调高了。</p><h3 id="其他的资源限制"><a href="#其他的资源限制" class="headerlink" title="其他的资源限制"></a>其他的资源限制</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 当前用户所允许的最大并发进程数</span></div><div class="line">Process.getrlimit(<span class="symbol">:NPROC</span>)</div><div class="line"></div><div class="line"><span class="comment"># 可创建的最大文件</span></div><div class="line">Process.getrlimit(<span class="symbol">:FSIZE</span>)</div><div class="line"></div><div class="line"><span class="comment"># 进程栈的最大段的大小</span></div><div class="line">Process.getrlimit(<span class="symbol">:STACK</span>)</div></pre></td></tr></table></figure><p>相关的封装的系统调用指令<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ man 2 getrlimit</div><div class="line">$ man 2 setrlimit</div></pre></td></tr></table></figure></p><h2 id="进程的环境变量"><a href="#进程的环境变量" class="headerlink" title="进程的环境变量"></a>进程的环境变量</h2><p>每个进程都从它们各自的父进程中<strong>继承</strong>了环境变量。注意，环境变量具有<strong><code>全局性</code></strong>！</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ MESSAGE=<span class="string">'wing it'</span> ruby -e <span class="string">"puts ENV['MESSAGE']"</span></div></pre></td></tr></table></figure><p>在bash中可以通过<code>VAR=value</code>的语法设置环境变量，通过<code>$VAR</code>获取环境变量的值。而在Ruby中则从ENV常量获取或设置环境变量：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">ENV[<span class="string">'MESSAGE'</span>] = <span class="string">'wing it'</span></div><div class="line">system <span class="string">"echo $MESSAGE"</span></div></pre></td></tr></table></figure><blockquote><p>Ruby的<code>ENV</code> 不是哈希，它实现了<code>Enumerable</code>和部分<code>Hash API</code></p></blockquote><h3 id="环境变量实际应用"><a href="#环境变量实际应用" class="headerlink" title="环境变量实际应用"></a>环境变量实际应用</h3><p>环境变量通常被用于<strong>把输入传递到命令行程序中</strong>的通用方法，用环境变量作为命令行程序的输入比使用<em>选项</em><code>开销更低</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ RAILS_ENV=production rails server</div><div class="line">$ QUEUE=default rake resque:work</div></pre></td></tr></table></figure><blockquote><p>系统没有提供相应的系统调用去操作环境变量，但有C库函数可以<code>setenv(3) getenv(3) environ(7)</code></p></blockquote><h2 id="传递给进程的参数"><a href="#传递给进程的参数" class="headerlink" title="传递给进程的参数"></a>传递给进程的参数</h2><p>每个进程都能访问一个特殊的数组<code>ARGV</code>（或叫<code>argument vector</code> 参数向量）,它保存着在命令行中传递给进程的参数。在Ruby中它就是一个数组对象。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">ARGV.<span class="keyword">include</span>?(<span class="string">'--help'</span>)</div><div class="line"><span class="comment">#获取-c选项的值</span></div><div class="line">ARGV.<span class="keyword">include</span>?(<span class="string">'-c'</span>) &amp;&amp; ARGV[ARGV.index(<span class="string">'-c'</span>) + <span class="number">1</span>]</div></pre></td></tr></table></figure><h2 id="进程名"><a href="#进程名" class="headerlink" title="进程名"></a>进程名</h2><p>在Ruby中可以通过全局变量<code>$PROGRAM_NAME</code>（别名<code>$0</code>）来<strong>获取</strong>或<strong>修改</strong>当前进程名，改变进程名没什么意义。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">$PROGRAM_NAME</div><div class="line">$PROGRAM_NAME = <span class="string">'fuck name'</span></div></pre></td></tr></table></figure><h2 id="进程有退出码"><a href="#进程有退出码" class="headerlink" title="进程有退出码"></a>进程有退出码</h2><p>退出码范围（<code>0-255</code>）除了<code>0</code>以外，其他退出码都表示<strong>异常退出</strong>，退出码是进程通信的方式之一。</p><p>Ruby的退出方式<code>Kernel#exit</code>，最简单的进程退出方式，返回退出码<code>0</code>，也是脚本执行结束的默认退出方式。</p><h3 id="Kernel-exit"><a href="#Kernel-exit" class="headerlink" title="Kernel#exit"></a><code>Kernel#exit</code></h3><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 退出码0 正常退出</span></div><div class="line">exit</div><div class="line"><span class="comment"># 进程退出前调用</span></div><div class="line">at_exit &#123;puts <span class="string">'last!'</span>&#125;</div><div class="line">exit</div><div class="line"><span class="comment"># 返回退出码22</span></div><div class="line">exit <span class="number">22</span></div></pre></td></tr></table></figure><h3 id="Kernel-exit-1"><a href="#Kernel-exit-1" class="headerlink" title="Kernel#exit!"></a><code>Kernel#exit!</code></h3><blockquote><p>退出前不会执行 <code>at_exit</code> 块中的代码！！！</p></blockquote><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 返回默认退出码1</span></div><div class="line">exit!</div><div class="line">exit! <span class="number">33</span>  <span class="comment">#返回退出码33</span></div></pre></td></tr></table></figure><h3 id="Kernel-abort"><a href="#Kernel-abort" class="headerlink" title="Kernel#abort"></a><code>Kernel#abort</code></h3><ul><li><code>abort</code> 提供了从错误进程中退出的通用方式</li><li>传递的消息会在进程退出前打印到 <code>STDERR</code></li><li>返回默认退出码 <code>1</code></li><li><code>abort</code> 退出会调用 <code>at_exit</code> 块</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">abort</div><div class="line">abort <span class="string">"something wrong"</span></div><div class="line">at_exit &#123;puts <span class="string">'last!'</span>&#125;</div><div class="line">abort</div></pre></td></tr></table></figure><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a><code>raise</code></h3><ul><li>不会马上使进程结束，但如果没有 <code>rescue</code> 处理这个异常，进程就会退出返回退出码 <code>1</code>。</li><li><code>at_exit</code> 块会被调用，异常信息打印到 STDERR</li></ul><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">raise <span class="string">'hell'</span></div></pre></td></tr></table></figure><h2 id="进程衍生forking"><a href="#进程衍生forking" class="headerlink" title="进程衍生forking"></a>进程衍生<code>forking</code></h2><ol><li>衍生出的子进程继承了父进程所有的<strong>内存拷贝</strong></li><li>子进程<strong>随意更改</strong>内存内容而不会对父进程造成影响</li><li>也继承了父进程的<strong>文件描述符</strong></li><li>也获得了父进程的所有文件描述符的<strong>编号</strong></li><li>进程间就共享了这些打开的文件或sockets，以便<strong>进程间通信</strong></li><li>子进程是一个全新的进程，有自己的<strong>pid</strong></li><li>衍生<strong>调用很快</strong>，几乎瞬间完成。</li><li>衍生可能造成<strong>内存过载</strong></li></ol><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">puts <span class="string">"parent pid is <span class="subst">#&#123;Process.pid&#125;</span>"</span></div><div class="line"><span class="keyword">if</span> fork</div><div class="line">  puts <span class="string">"enter if from <span class="subst">#&#123;Process.pid&#125;</span>"</span>   <span class="comment">#父进程执行</span></div><div class="line"><span class="keyword">else</span></div><div class="line">  puts <span class="string">"enter else from <span class="subst">#&#123;Process.pid&#125;</span>"</span> <span class="comment">#子进程执行</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><blockquote><p>在子进程中<code>fork</code>返回<code>nil</code>，父进程中<code>fork</code>返回创建的子进程<code>pid</code>。</p></blockquote><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 父进程跳过块，块在子进程中执行，执行后子进程会退出。</span></div><div class="line">fork <span class="keyword">do</span></div><div class="line">  xxx</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><blockquote><p>系统调用<code>$ man 2 fork</code></p></blockquote><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><ul><li>当父进程退出后，<strong>子进程未退出</strong>，子进程就变成了孤儿进程</li><li>父进程退出后，子进程照常运行，父进程不会带着子进程同归于尽</li><li><strong>守护进程是孤儿进程</strong>，有意让守护进程安静的保持运行</li><li>可以通过<code>Unix信号</code>与脱离终端会话的进程进行通信，从而管理孤儿进程。</li></ul><h2 id="写时复制CoW"><a href="#写时复制CoW" class="headerlink" title="写时复制CoW"></a>写时复制<code>CoW</code></h2><p><code>CoW</code>，copy-on-write，fork 出的子进程如果直接物理拷贝开销会很大，于是现代的unix系统提出了一个CoW的概念，延迟内存拷贝，直接它需要对内存进行写操作。所以父子进程会共享同一片物理内存数据，直到它们当中某一个进程需要改变内存数据。其他没变的内存数据还是共享的。</p><p>但不幸的是<strong>MRI</strong>或<strong>Rubinius</strong>并不支持CoW，因为MRI的垃圾回收使用<code>mark-and-sweep</code>标记清除算法，当GC时，会迭代每个对象并写入信息。fork之后，当第一次GC，写时复制带来的好处会被撤销。</p><blockquote><p>Ruby企业版<code>REE</code>是<code>CoW</code>友好的。</p></blockquote><h2 id="进程等待Process-wait"><a href="#进程等待Process-wait" class="headerlink" title="进程等待Process.wait"></a>进程等待<code>Process.wait</code></h2><p><strong>阻塞调用</strong>，会让父进程等待它<strong>任意一个</strong>子进程退出，然后才会继续执行下去。该方法<strong>返回值</strong>是退出的子程序<code>pid</code>，表示等到的退出的子程序。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">Process.wait</div></pre></td></tr></table></figure><h3 id="Process-wait2"><a href="#Process-wait2" class="headerlink" title="Process.wait2"></a><code>Process.wait2</code></h3><p>返回<code>pid</code>和<code>status</code>，<code>status</code>是一个<code>Process::Status</code>实例对象，包含大量有用信息。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Process.wait2</span></div><div class="line"><span class="comment"># ==</span></div><div class="line">fork <span class="keyword">do</span></div><div class="line">  exit <span class="number">111</span></div><div class="line"><span class="keyword">end</span></div><div class="line">pid, status = Process.wait2</div><div class="line">puts status.exitstatus  <span class="comment">#返回111</span></div><div class="line"><span class="comment"># ==</span></div><div class="line"><span class="comment"># 进程间通信就不需要依赖文件系统和网络！</span></div></pre></td></tr></table></figure><h3 id="Process-waitpid"><a href="#Process-waitpid" class="headerlink" title="Process.waitpid"></a><code>Process.waitpid</code></h3><p>等待<strong>特定</strong>的子进程</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">Process.waitpid &lt;pid&gt;</div><div class="line">Process.waitpid2 &lt;pid&gt;</div><div class="line"></div><div class="line"><span class="comment"># 等同于 Process.wait</span></div><div class="line">Process.waitpid -<span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 等同于 Process.waitpid 111</span></div><div class="line">Process.wait <span class="number">111</span></div></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">favourite = fork <span class="keyword">do</span></div><div class="line">  exit <span class="number">77</span></div><div class="line"><span class="keyword">end</span></div><div class="line">middle_child = fork <span class="keyword">do</span></div><div class="line">  abort <span class="string">"I want to be waited on!"</span></div><div class="line"><span class="keyword">end</span></div><div class="line">pid, status = Process.waitpid2 favourite</div><div class="line">puts status.exitstatus</div></pre></td></tr></table></figure><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><blockquote><p>问：当处理退出进程的代码还在运行时，有别的子进程退出，会发生什么？<br>答：内核会把退出进程的信息放入队列，所以父进程能<strong>依次</strong>接收子进程的退出信息。</p></blockquote><p>如果没有子进程执行时去<code>wait</code>会触发异常<code>Errno::ECHILD</code>，所以要记录好创建了多少个子进程。</p><p>关注子进程的做法是一个很普遍的UNIX编程模式，通常叫做<strong>看顾进程</strong>、<code>master/worker</code> 或者<code>preforking</code>。<br>核心概念是，一个主进程fork出多个子进程来并行，主进程负责管理子进程，确保子进程响应或者对子进程退出做出回应。</p><blockquote><p>系统调用 <code>$man 2 waitpid</code></p></blockquote><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>内核会一直<strong>保留</strong>已退出的子进程的<strong>状态信息</strong>，直到父进程使用<code>Process.wait</code>请求这些信息。<br>如果父进程一直不请求这些状态，内核就不会回收资源。任何子进程如果在结束时父进程仍在运行，那么这个子进程很快就会变成<strong>僵尸进程</strong>。</p><p>如果你不打算使用<code>Process.wait</code>来等待某个子进程退出，那么你需要分离<code>detach</code>这些子进程。以免变成<strong>僵尸进程</strong>。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">pid = fork <span class="keyword">do</span></div><div class="line">  xxx</div><div class="line"><span class="keyword">end</span></div><div class="line">Process.detach(pid)</div></pre></td></tr></table></figure><p><code>detach</code>的工作就是生出一个新的线程，<strong>唯一的任务就是等待这个特定的子进程结束</strong>。<code>detach</code>就保证了内核不会保留不需要的状态信息。</p><p><code>$ ps -ho pid,state -p &lt;pid of zombie&gt;</code></p><h2 id="Unix信号"><a href="#Unix信号" class="headerlink" title="Unix信号"></a>Unix信号</h2><p>通过捕获<code>:CHLD</code>信号，当有子进程退出时，父进程会被内核通知。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">trap(<span class="symbol">:CHLD</span>) <span class="keyword">do</span></div><div class="line">  puts Process.wait</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><h3 id="信号并发传递"><a href="#信号并发传递" class="headerlink" title="信号并发传递"></a>信号并发传递</h3><p><strong>信号传递是不可靠的</strong>，当代码在处理CHLD信息时，有其他子进程退出，你可能会也可能不会收到第二个CHLD信号。</p><p>要正确处理<code>CHLD</code>，必须在一个循环中调用<code>Process.wait</code>，查找所有已经结束的子进程。</p><p>要避免<code>Process.wait</code>阻塞，可以使用wait方法的第二个参数，告诉内核如果没有子进程退出，就不需要进行阻塞。</p><blockquote><p><code>Process.wait(-1, Process::WNOHANG)</code></p></blockquote><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">child_processes = <span class="number">3</span></div><div class="line">dead_processes = <span class="number">0</span></div><div class="line"><span class="comment"># 衍生出3个子进程</span></div><div class="line">child_processes.times <span class="keyword">do</span></div><div class="line">  fork <span class="keyword">do</span></div><div class="line">    sleep <span class="number">3</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">$stdout.sync = <span class="literal">true</span></div><div class="line"></div><div class="line">trap(<span class="symbol">:CHLD</span>) <span class="keyword">do</span></div><div class="line">  <span class="keyword">begin</span></div><div class="line">    <span class="keyword">while</span> pid = Process.wait(-<span class="number">1</span>, Process::WNOHANG)</div><div class="line">      puts pid</div><div class="line">      dead_processes += <span class="number">1</span></div><div class="line">      exit <span class="keyword">if</span> dead_processes == child_processes</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">rescue</span> Errno::ECHILD</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">loop <span class="keyword">do</span></div><div class="line">  (Math.sqrt(rand(<span class="number">44</span>)) ** <span class="number">8</span> ).floor</div><div class="line">  sleep <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><h3 id="信号基本概念"><a href="#信号基本概念" class="headerlink" title="信号基本概念"></a>信号基本概念</h3><p>信号是一种<strong>异步通信机制</strong>。当进程从内核那里接收到信号时，它可以做以下事情：</p><ol><li>忽略信号</li><li>执行特定操作</li><li>执行默认操作</li></ol><p>信号从一个进程发送到另一个进程，借助内核作为中介。</p><blockquote><p>信号最初的设计目的是为了以不同的方式去终结进程。</p></blockquote><p>以下代码是一个进程给另一进程发信号，用<code>Process.kill</code></p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 进程一</span></div><div class="line">puts Process.pid</div><div class="line">sleep</div><div class="line"></div><div class="line"><span class="comment"># 进程二</span></div><div class="line">Process.kill(<span class="symbol">:INT</span>, &lt;pid-of-first-process&gt;)</div></pre></td></tr></table></figure><h3 id="重新定义信号的行为"><a href="#重新定义信号的行为" class="headerlink" title="重新定义信号的行为"></a>重新定义信号的行为</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">trap(<span class="symbol">:INT</span>) &#123;print <span class="string">"nananana"</span>&#125;</div><div class="line">trap(<span class="symbol">:INT</span>, <span class="string">"IGNORE"</span>) <span class="comment"># 忽略信号</span></div></pre></td></tr></table></figure><p>现在我们的进程就算收到INT信号也不会退出。</p><p>只有<code>SIGKILL</code>信号是不会被重定义的。一般我们还是<strong>不要重定义这些信号</strong>，要重定义，就重定义<code>SIGUSR1</code>和<code>SIGUSR2</code>信号</p><p>全部信号定义</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">Signal.list</div></pre></td></tr></table></figure><p>重定义信号的行为是全局性的，因此要小心不要影响到其他代码。</p><blockquote><p>系统调用<br><code>$ man 2 sigaction</code><br><code>$ man 7 signal</code></p></blockquote><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><strong>进程间通信</strong>，<code>IPC</code>, <code>Inter-process communication</code><br>常用的方式是管道<code>pipes</code>和套接字对<code>socket pairs</code></p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是单向数据流，一个进程拥有管道的一端，另一进程拥有另一端。</p><p>如果不关闭<code>writer</code>端，<code>reader</code>端会不断尝试读取数据，直到读到<code>EOF</code>，在这之前reader会<strong>阻塞</strong>。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">reader, writer = IO.pipe</div><div class="line"><span class="comment"># =&gt; [#&lt;IO:fd 5&gt;, #&lt;IO:fd 6&gt;]</span></div><div class="line"></div><div class="line">writer.write(<span class="string">"Into the pipe I go"</span>)</div><div class="line">writer.close</div><div class="line">puts reader.read</div></pre></td></tr></table></figure><h3 id="共享管道"><a href="#共享管道" class="headerlink" title="共享管道"></a>共享管道</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">reader, writer = IO.pipe</div><div class="line">fork <span class="keyword">do</span></div><div class="line">  <span class="comment"># 子进程中写数据</span></div><div class="line">  reader.close</div><div class="line">  <span class="number">10</span>.times <span class="keyword">do</span></div><div class="line">    writer.puts <span class="string">"xxx"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">writer.close</div><div class="line"><span class="comment"># 父进程读数据</span></div><div class="line"><span class="keyword">while</span> message = reader.gets</div><div class="line">  $stdout.puts message</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>由于文件描述符会拷贝，现在就有4个实例，只要两个用于通信，另外两个就需要关闭。</p><p>注意这里用<code>gets</code>和<code>puts</code>，在管道中传递的是数据流<code>stream</code>，有特定的分隔符<code>\n</code>，当读取数据流时，每次只会读取一截，以分隔符分隔。</p><h3 id="SOCKET通信"><a href="#SOCKET通信" class="headerlink" title="SOCKET通信"></a><code>SOCKET</code>通信</h3><p>可以使用<code>消息</code>代替流进行通信，但无法在管道中使用消息，不过在<code>Unix套接字</code>中就可以。</p><p><code>Unix套接字</code>是套接字的一种类型，它只能在同一台物理机器上进行通信。因此比<code>TCP套接字</code>要快很多。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 创建一对可以通过*消息*来通信的Unix套接字</span></div><div class="line"><span class="comment"># 一对已经互相连接好的套接字，不使用流，而是使用数据报通信，写入整个消息，无需分隔符</span></div><div class="line"><span class="keyword">require</span> <span class="string">'socket'</span></div><div class="line">Socket.pair(<span class="symbol">:UNIX</span>, <span class="symbol">:DGRAM</span>, <span class="number">0</span>)</div><div class="line"><span class="comment"># =&gt; [#&lt;Socket:fd 15&gt;, #&lt;Socket:fd 16&gt;]</span></div></pre></td></tr></table></figure><p>管道提供的是单向通信，套接字对提供的是双向通信。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'socket'</span></div><div class="line">child_socket, parent_socket = Socket.pair(<span class="symbol">:UNIX</span>, <span class="symbol">:DGRAM</span>, <span class="number">0</span>)</div><div class="line">maxlen = <span class="number">1000</span></div><div class="line">fork <span class="keyword">do</span></div><div class="line">  parent_socket.close</div><div class="line">  <span class="number">4</span>.times <span class="keyword">do</span></div><div class="line">    instruction = child_socket.recv(maxlen)</div><div class="line">    child_socket.send(<span class="string">"<span class="subst">#&#123;instruction&#125;</span> accomplished"</span>, <span class="number">0</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">child_socket.close</div><div class="line"><span class="number">2</span>.times <span class="keyword">do</span></div><div class="line">  parent_socket.send(<span class="string">"Heavy"</span>, <span class="number">0</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="number">2</span>.times <span class="keyword">do</span></div><div class="line">  parent_socket.send(<span class="string">"Feather"</span>, <span class="number">0</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="number">4</span>.times <span class="keyword">do</span></div><div class="line">  $stdout.puts parent_socket.recv(maxlen)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><blockquote><p>系统调用<br><code>$man 2 pipe</code><br><code>$man 2 socketpair</code><br><code>$man 2 recv</code><br><code>$man 2 send</code></p></blockquote><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>首个进程<code>init</code>进程，<code>pid</code>为<code>1</code>，就是一个<strong>守护进程</strong>。它的<code>ppid</code>为<code>0</code></p><p>任意进程都能变成守护进程，这里拿rack项目为例</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">daemonize_app</span></span></div><div class="line">  <span class="keyword">if</span> RUBY_VERSION &lt; <span class="string">"1.9"</span></div><div class="line">    <span class="comment"># 父进程退出，调用脚本的终端会认为命令已经结束</span></div><div class="line">    <span class="comment"># 返回控制权给终端。</span></div><div class="line">    <span class="comment"># 子进程变成了孤儿进程，孤儿进程的PPID为1</span></div><div class="line">    exit <span class="keyword">if</span> fork</div><div class="line"></div><div class="line">    <span class="comment"># 使衍生进程成为一个新进程组和会话组的leader</span></div><div class="line">    <span class="comment"># 新的会话组就不会有控制终端了</span></div><div class="line">    <span class="comment"># 只能从子进程调用，如果进程已经是组长，调用会失败</span></div><div class="line">    Process.setsid</div><div class="line"></div><div class="line">    <span class="comment"># 控制终端只能分配给会话领导，再次衍生的进程就绝不会有</span></div><div class="line">    <span class="comment"># 确保脱离控制终端，独立运行，守护进程</span></div><div class="line">    exit <span class="keyword">if</span> fork</div><div class="line"></div><div class="line">    <span class="comment"># 确保守护进程的工作目录不会消失</span></div><div class="line">    Dir.chdir <span class="string">"/"</span></div><div class="line"></div><div class="line">    <span class="comment"># 把标准输入输出干掉，因为不需要，但不能直接close</span></div><div class="line">    <span class="comment"># 其他程序还是需要它们的</span></div><div class="line">    STDIN.reopen <span class="string">"/dev/null"</span></div><div class="line">    STDOUT.reopen <span class="string">"/dev/null"</span>, <span class="string">"a"</span></div><div class="line">    STDERR.reopen <span class="string">"/dev/null"</span>, <span class="string">"a"</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="comment"># 1.9版本后才附带的方法，把当前进程变成守护进程</span></div><div class="line">    Process.daemon</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><blockquote><p>衍生的进程虽然摆脱了终端，但依然继承了gid和sid，终端依然有办法能给fork出的进程发信号。但我们需要我们的进程彻底摆脱（<code>detach</code>）终端。<code>Process.setsid</code>会使得当前进程成为<strong>新的</strong>进程组和session组的leader。（leader能被终端发送信号）</p><p>变leader之后需要再fork一个新的子进程出来，然后leader退出，最后这个子进程（既没有控制它的终端，也不是leader）就是需要的守护进程了！！！</p></blockquote><h3 id="调用Process-setsid的作用"><a href="#调用Process-setsid的作用" class="headerlink" title="调用Process.setsid的作用"></a>调用<code>Process.setsid</code>的作用</h3><ol><li>该进程变成一个新会话的会话领导</li><li>该进程变成一个新进程组的组长</li><li>该进程没有控制终端</li></ol><h3 id="进程组和会话组"><a href="#进程组和会话组" class="headerlink" title="进程组和会话组"></a>进程组和会话组</h3><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><ol><li>每个进程都有一个所属的<strong>组</strong>，每个组都有唯一的id（通常是<code>leader</code>进程的<code>pid</code>，也是在终端里输入命令启动的进程id）</li><li>一个进程组是一些相关进程的集合，通常是父进程和它的子进程们的集合。</li><li>也可以任意组合进程组</li><li><strong>终端</strong>接收信号，会将信号转发给<strong>前台进程组</strong>中的<strong>每个进程</strong>，因此如果在终端发送信息，进程组里的所有进程都会受影响。</li></ol><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 通常这个组id会跟组leader进程的pid相同</span></div><div class="line">Process.getpgrp</div><div class="line"><span class="comment"># 设置进程的组ID</span></div><div class="line">Process.setpgrp(new_group_id)</div></pre></td></tr></table></figure><blockquote><p>系统调用<code>$ man 2 getpgrp</code></p></blockquote><h4 id="会话组"><a href="#会话组" class="headerlink" title="会话组"></a>会话组</h4><p>会话组是更高一级的抽象，是进程组的集合。</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">git <span class="built_in">log</span> | grep shipped | less</div></pre></td></tr></table></figure><p>这些指令创建了3个独立的进程组，但ctrl-c还是能一次性把它们都干掉，因为它们处于同一个会话组。在<code>shell</code>中的每<strong>一次调用</strong>都会获得自己的<code>会话租</code>（<strong>一次调用</strong>可以是单个命令，也可以是由管道连接的一串命令）</p><blockquote><p>系统调用 <code>$man 2 getsid</code> 能获取当前的会话组ID<br>但Ruby没有相应的接口，使用<code>Process.setsid</code>会新建一个会话组并返回会话组ID</p></blockquote><h2 id="生成终端进程"><a href="#生成终端进程" class="headerlink" title="生成终端进程"></a>生成终端进程</h2><p>Ruby程序中一个常见的交互是在程序中通过shelling out的方式在终端执行某个命令，这在编写Ruby脚本来将若干常用命令粘合在一起时尤为常见。（在Ruby中生成进程来执行终端命令）</p><h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel#`"></a>Kernel#`</h3><p>返回字符串</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="string">`ls`</span></div><div class="line"><span class="string">`ls --help`</span></div></pre></td></tr></table></figure><h3 id="x-cmd"><a href="#x-cmd" class="headerlink" title="%x( cmd )"></a><code>%x( cmd )</code></h3><p>反引号与<code>%x</code>作用相同</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="string">%x[git log | tail -10]</span></div></pre></td></tr></table></figure><h3 id="Kernel-system"><a href="#Kernel-system" class="headerlink" title="Kernel#system"></a><code>Kernel#system</code></h3><p><code>Kernel#system</code> 返回 <code>true</code> 或者 <code>false</code> ，当终端命令退出码是 <code>0</code> 时，方法返回 <code>true</code>。</p><p>生成的进程与当前进程共享标准流（stdout stdin stderr），但会<strong>阻塞调用</strong></p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">system(<span class="string">'ls'</span>)</div><div class="line">system(<span class="string">'ls'</span>, <span class="string">'--help'</span>)</div></pre></td></tr></table></figure><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><ul><li><code>exec</code> 命令能让你把当前进程替换成一个不同的进程。</li><li><code>exec</code> 替换进程后是不会返回到原来的进程的。</li><li>需要联合使用<code>fork+exec</code>。专门fork出一个进程来exec，这时候可以使用之前的<code>Process.wait</code>来等待退出码。</li></ul><p>你可以把当前的Ruby进程转换成一个Python进程或者一个<code>ls</code>进程。</p><p><code>exec</code>不会关闭文件，也不做内存清理，以下代码是在Ruby中打开文件，然后生成一个Python进程去读取这个文件，在Ruby中打开了，在Python中就不需要再次打开了</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">hosts = File.open(<span class="string">'/etc/hosts'</span>)</div><div class="line">exec <span class="string">'python'</span>, <span class="string">'-c'</span>, <span class="string">"import os; print os.fdopen(<span class="subst">#&#123;hosts.fileno&#125;</span>).read()"</span></div></pre></td></tr></table></figure><blockquote><p><code>$man 2 exec</code></p></blockquote><p>参数可以是<code>字符串</code>，也可以是<code>数组</code>，之间有微妙的不同。</p><ul><li>字符串参数表示它会启动一个<code>shell进程</code>，然后把字符串参数传给shell去解析；</li><li>数组参数的话，它会跳过shell进程，而直接把数组作为新进程的<code>ARGV参数</code>。</li></ul><p>推荐使用数组参数，字符串参数有安全问题。</p><h3 id="Process-spawn"><a href="#Process-spawn" class="headerlink" title="Process.spawn"></a><code>Process.spawn</code></h3><p><code>Process.spawn</code> 非阻塞调用，返回<code>shelling out</code>进程的PID</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">Process.spawn(&#123;<span class="string">'RAILS_ENV'</span> =&gt; <span class="string">'test'</span>&#125;, <span class="string">'rails server'</span>)</div><div class="line">system <span class="string">'sleep 5'</span>  <span class="comment">#阻塞</span></div><div class="line">Process.spawn <span class="string">'sleep 5'</span>   <span class="comment">#非阻塞</span></div><div class="line"></div><div class="line">pid = Process.spawn <span class="string">'sleep 5'</span></div><div class="line">Process.waitpid(pid)</div></pre></td></tr></table></figure><h3 id="IO-popen"><a href="#IO-popen" class="headerlink" title="IO.popen"></a><code>IO.popen</code></h3><p><code>IO.popen</code>是用纯Ruby实现的unix管道，在底层，它还是在做<code>fork+exec</code>的事情，不过它同时也建立<strong>管道</strong>来跟<strong>生成的进程</strong><code>通信</code>。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># IO对象stream传进代码块中，打开stream进行写入。</span></div><div class="line"><span class="comment"># 将stream设置成生成进程的STDIN</span></div><div class="line">IO.popen(<span class="string">'less'</span>, <span class="string">'w'</span>) <span class="keyword">do</span> <span class="params">|stream|</span></div><div class="line">  stream.puts <span class="string">"some\ndata"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment"># 因此这个流设置成了派生进程的标准输入，如果打开流来读，那么流就是派生进程的标准输出。你只能选一端</span></div></pre></td></tr></table></figure><h3 id="Open3-popen3"><a href="#Open3-popen3" class="headerlink" title="Open3.popen3"></a><code>Open3.popen3</code></h3><figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'open3'</span></div><div class="line">Open3.popen3(<span class="string">'grep'</span>, <span class="string">'data'</span>) &#123; <span class="params">|stdin, stdout, stderr|</span></div><div class="line">  stdin.puts <span class="string">"some\ndata"</span></div><div class="line">  stdin.close</div><div class="line">  puts stdout.read</div><div class="line">&#125;</div><div class="line">Open3.popen3(<span class="string">'ls'</span>, <span class="string">'-uhh'</span>, <span class="symbol">:err</span> =&gt; <span class="symbol">:out</span>) &#123; <span class="params">|stdin, stdout, stderr|</span></div><div class="line">  puts stdout.read</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Unix系统组成：用户空间&lt;code&gt;userland&lt;/code&gt;与内核&lt;code&gt;kernel&lt;/code&gt;
      
    
    </summary>
    
      <category term="ruby" scheme="http://luhaozhao.com/categories/ruby/"/>
    
    
      <category term="ruby" scheme="http://luhaozhao.com/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>GPG 备忘</title>
    <link href="http://luhaozhao.com/2017/08/24/gpg/"/>
    <id>http://luhaozhao.com/2017/08/24/gpg/</id>
    <published>2017-08-24T16:06:36.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><div class="line"><span class="keyword">brew </span>update</div><div class="line"><span class="keyword">brew </span>search gpg</div><div class="line"><span class="keyword">brew </span><span class="keyword">install </span>gpg</div></pre></td></tr></table></figure><h3 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h3><p><code>gpg --help</code></p><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p><code>gpg --gen-key</code></p><p>按提示填写资料后生成密钥对</p><h4 id="密钥回收"><a href="#密钥回收" class="headerlink" title="密钥回收"></a>密钥回收</h4><p>生成密钥对后应该立即做一个公钥回收证书，通过发布证书声明之前的公钥不再有效。</p><p><code>gpg --output foo_revoke.asc --gen-revoke [uid]</code></p><h3 id="列出系统中已有密钥"><a href="#列出系统中已有密钥" class="headerlink" title="列出系统中已有密钥"></a>列出系统中已有密钥</h3><p><code>gpg --list-keys</code></p><h3 id="删除密钥"><a href="#删除密钥" class="headerlink" title="删除密钥"></a>删除密钥</h3><p>必须先删除私钥才能删除公钥</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><div class="line">gpg --<span class="keyword">delete</span>-secret-<span class="keyword">keys</span> [uid]</div><div class="line">gpg --<span class="keyword">delete</span>-<span class="keyword">key</span> [uid]</div></pre></td></tr></table></figure><h2 id="发布密钥到全球性的密钥服务器"><a href="#发布密钥到全球性的密钥服务器" class="headerlink" title="发布密钥到全球性的密钥服务器"></a>发布密钥到全球性的密钥服务器</h2><p><code>gpg --keyserver subkeys.pgp.net --send-keys [uid]</code></p><h3 id="导入密钥"><a href="#导入密钥" class="headerlink" title="导入密钥"></a>导入密钥</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><div class="line">gpg <span class="params">--import</span> [密钥文件]</div><div class="line">gpg <span class="params">--keyserver</span> hkp:<span class="string">//subkeys.pgp.net</span> <span class="params">--search-keys</span> [用户id]</div><div class="line"><span class="comment"># 无法保证服务器上的公钥是否可靠，下载后还需要其他机制验证。</span></div><div class="line">gpg <span class="params">--fingerprint</span> [uid] <span class="comment"># 生成公钥指纹，在网站上公布，让其他人核对下载的公钥是否为真。</span></div></pre></td></tr></table></figure><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">gpg --recipient [加密的公钥] --output demo<span class="selector-class">.en</span><span class="selector-class">.txt</span> --encrypt demo.txt</div><div class="line">gpg --output demo<span class="selector-class">.de</span><span class="selector-class">.txt</span> --decrypt demo<span class="selector-class">.en</span><span class="selector-class">.txt</span></div></pre></td></tr></table></figure><h2 id="签名与验证"><a href="#签名与验证" class="headerlink" title="签名与验证"></a>签名与验证</h2><h3 id="生成未分离的签名文件"><a href="#生成未分离的签名文件" class="headerlink" title="生成未分离的签名文件"></a>生成未分离的签名文件</h3><figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">gpg</span> <span class="selector-tag">--sign</span> <span class="selector-tag">demo</span><span class="selector-class">.txt</span></div><div class="line"># 自动生成<span class="selector-tag">demo</span><span class="selector-class">.txt</span><span class="selector-class">.gpg</span>文件，是签名后的二进制文件</div><div class="line"><span class="selector-tag">gpg</span> <span class="selector-tag">--clearsign</span> <span class="selector-tag">demo</span><span class="selector-class">.txt</span></div><div class="line"># 自动生成<span class="selector-tag">demo</span><span class="selector-class">.txt</span><span class="selector-class">.asc</span>文件，是签名后的<span class="selector-tag">ASCII</span>文件</div></pre></td></tr></table></figure><h3 id="生成单独的签名文件"><a href="#生成单独的签名文件" class="headerlink" title="生成单独的签名文件"></a>生成单独的签名文件</h3><p>签名文件与文件内容分开存放</p><figure class="highlight maxima"><table><tr><td class="code"><pre><div class="line">gpg --detach-<span class="built_in">sign</span> <span class="built_in">demo</span>.txt</div><div class="line"># 生成单独的二进制签名文件<span class="built_in">demo</span>.txt.sig</div><div class="line">gpg --armor --detach-<span class="built_in">sign</span> <span class="built_in">demo</span>.txt</div><div class="line"># 生成单独的ASCII签名文件<span class="built_in">demo</span></div></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight autoit"><table><tr><td class="code"><pre><div class="line">gpg --verify demo.txt.<span class="built_in">asc</span> <span class="meta"># 验证未分离的签名文件</span></div><div class="line">gpg --verify demo.txt <span class="built_in">asc</span> demo.txt <span class="meta"># 验证分离的签名文件</span></div></pre></td></tr></table></figure><h3 id="签名并加密"><a href="#签名并加密" class="headerlink" title="签名并加密"></a>签名并加密</h3><figure class="highlight brainfuck"><table><tr><td class="code"><pre><div class="line"><span class="comment">gpg</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">local</span><span class="literal">-</span><span class="comment">user</span> <span class="title">[</span><span class="comment">发信者id</span><span class="title">]</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">recipient</span> <span class="title">[</span><span class="comment">接收者id</span><span class="title">]</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">armor</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">sign</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">encrypt</span> <span class="comment">demo</span><span class="string">.</span><span class="comment">txt</span></div></pre></td></tr></table></figure><p>用decrypt解密即可，gpg会自动验证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div c
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="gpg" scheme="http://luhaozhao.com/tags/gpg/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL 用法备忘</title>
    <link href="http://luhaozhao.com/2017/08/24/openssl/"/>
    <id>http://luhaozhao.com/2017/08/24/openssl/</id>
    <published>2017-08-24T16:06:30.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<ul><li>用对方的公钥来加密，发给对方后，对方用私钥解密</li><li>用自己的私钥签名，对方收到用，用我的公钥来验证</li></ul><h2 id="SSL-协议的握手过程"><a href="#SSL-协议的握手过程" class="headerlink" title="SSL 协议的握手过程"></a>SSL 协议的握手过程</h2><ol><li>Client 发送协议版本号、随机数random1、支持的加密算法 ===&gt; Server</li><li>Server 确认双方使用的加密算法 encryption 、给出数字证书 cert 以及生成一个随机数 random2 ===&gt; Client</li><li>Client 确认cert 有效，再生成一个随机数 random3 并用cert中的公钥对其加密 encrypt_random3 ===&gt; Server (Client 握手结束通知)</li><li>Server 用自己的私钥解密 encrypt_random3 得到 random3 (Server 握手结束通知)</li></ol><p>双方使用确定的加密算法 encryption 对 random1 random2 random3 加密生成对话密钥 session_key ，这个session_key 对接下来的对话过程进行对称加密</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><h3 id="enc-子命令"><a href="#enc-子命令" class="headerlink" title="enc 子命令"></a>enc 子命令</h3><p>用于对称加密</p><p>加密，要求使用者输入密码</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl enc -e -des3 -a -salt -<span class="keyword">in</span> foo -out foo.encrypt</div></pre></td></tr></table></figure><ul><li><code>-e</code> 进行加密操作</li><li><code>-des3</code> 加密算法 <code>-aes256</code></li><li><code>-in</code> 输入文件</li><li><code>-out</code> 输出文件</li></ul><p>解密，要求使用者输入密码</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl enc -d -des3 -a -salt -<span class="keyword">in</span> foo.encrypt -out foo.decrypt</div></pre></td></tr></table></figure><ul><li><code>-d</code> 进行解密操作</li></ul><h3 id="rand-子命令"><a href="#rand-子命令" class="headerlink" title="rand 子命令"></a>rand 子命令</h3><p>用于生成随机数</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl rand -base64 6</div><div class="line">openssl rand -hex 30</div></pre></td></tr></table></figure><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="genrsa-子命令"><a href="#genrsa-子命令" class="headerlink" title="genrsa 子命令"></a>genrsa 子命令</h3><p>生成私钥</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl genrsa -out private_key.pem 1024</div></pre></td></tr></table></figure><p>以私钥生成对应公钥</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl rsa -<span class="keyword">in</span> private_key.pem -out public_key.pem -outform PEM -pubout</div></pre></td></tr></table></figure><h3 id="rsautl-子命令"><a href="#rsautl-子命令" class="headerlink" title="rsautl 子命令"></a>rsautl 子命令</h3><p>公钥加密</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl rasutl -encrypt -inkey public_key.pem -pubin -<span class="keyword">in</span> test.txt -out test.txt.encrypt</div></pre></td></tr></table></figure><p>私钥解密</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl rasutl -decrypt -inkey private_key.pem -<span class="keyword">in</span> test.txt.encrypt -out test.txt.decrypt</div></pre></td></tr></table></figure><h3 id="大文件加密"><a href="#大文件加密" class="headerlink" title="大文件加密"></a>大文件加密</h3><p>这种方式无法对任意大小的文件加密，文件太大会报错，可以用另一种方式对大文件进行非对称加密：</p><ul><li>产生随机数，以随机数作为密码对大文件进行对称加密</li><li>然后把随机数密码进行非对称加密</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl rand -base64 64 &gt; key.bin</div><div class="line">openssl enc -aes-256-cbc -salt -<span class="keyword">in</span> test.txt -out test.txt.encrypt -pass file:key.bin</div><div class="line">open rsautl -encrypt -inkey public_key.pem -pubin -<span class="keyword">in</span> key.bin -out key.bin.encrypt</div></pre></td></tr></table></figure><p>解密</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl rsautl -decrypt -inkey private_key.pem -<span class="keyword">in</span> key.bin.encrypt -out key.bin</div><div class="line">openssl enc -d -aes-256-cbc -<span class="keyword">in</span> test.txt.encrypt -out test.txt -pass file:key.bin</div></pre></td></tr></table></figure><h2 id="私有CA"><a href="#私有CA" class="headerlink" title="私有CA"></a>私有CA</h2><h3 id="构建私有CA"><a href="#构建私有CA" class="headerlink" title="构建私有CA"></a>构建私有CA</h3><blockquote><p>PKI public key infrastructure 公钥基础建设</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">mkdir -p /etc/pki/CA/private</div><div class="line"></div><div class="line"><span class="comment"># 生成私钥</span></div><div class="line">openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096</div><div class="line"></div><div class="line"><span class="comment"># 生成自签证书 -x509 生成自签格式证书，专用于创建私有CA</span></div><div class="line">openssl req -new -x509 \</div><div class="line">            -key /etc/pki/CA/private/cakey.pem\</div><div class="line">            -out /etc/pki/CA/cacert.pem\</div><div class="line">            -days 3655</div><div class="line"></div><div class="line"><span class="comment"># 为CA 提供需要的目录和文件</span></div><div class="line">mkdir -pv /etc/pki/CA/&#123;certs,crl,newcerts&#125;</div><div class="line">touch /etc/pki/CA/&#123;serial,index.txt&#125;</div><div class="line"><span class="built_in">echo</span> 01 &gt; /etc/pki/CA/serial</div></pre></td></tr></table></figure><h3 id="向CA请求签署证书"><a href="#向CA请求签署证书" class="headerlink" title="向CA请求签署证书"></a>向CA请求签署证书</h3><blockquote><p>第一步，生成私钥</p><p>第二步，生成证书签署请求 Certificate Signing Request CSR</p><p>第三步，把请求发送到CA主机</p><p>第四步，在CA主机上签署生成证书</p><p>第五步，把生成的证书发送到目标主机上</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">mkdir -p /etc/httpd/ssl &amp;&amp; <span class="built_in">cd</span> /etc/httpd/ssl</div><div class="line"></div><div class="line">openssl genrsa -out /etc/httpd/ssl/httpd.key 2048</div><div class="line"></div><div class="line">openssl req -new -key httpd.key -out httpd.csr -days 365 <span class="comment"># 生成签署请求</span></div><div class="line"></div><div class="line">scp httpd.csr foo@ca:/etc/pki/ca/certs <span class="comment"># 把请求发送到CA服务器上</span></div><div class="line"></div><div class="line">openssl ca -<span class="keyword">in</span> httpd.csr -out httpd.crt -days 365 <span class="comment"># 在CA上签署证书请求</span></div><div class="line"></div><div class="line">scp cer.crt foo@host:/etc/httpd/ssl <span class="comment"># 把签署证书拷贝回请求的主机上</span></div><div class="line"></div><div class="line">openssl x509 -<span class="keyword">in</span> httpd.crt -noout -serial -subject <span class="comment"># 查看证书中的信息 -serial 查看序列号 -subject 查看主体信息</span></div></pre></td></tr></table></figure><h3 id="吊销证书"><a href="#吊销证书" class="headerlink" title="吊销证书"></a>吊销证书</h3><p>在 CA 服务器上找到证书的序列号 serial</p><p>需要对比客户提交的 serial 和 subject 信息与 CA 本机数据库 index.txt 中存储的是否一致</p><blockquote><p>ubuntu@ubuntu-xenial:/etc/pki/demoCA$ cat index.txt</p><p>V  180824075225Z    01  unknown  /C=CN/ST=GD/O=youtiao/OU=dev/CN=luhaozhao/emailAddress=hzlu2010@gmail.com</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">openssl x509 -<span class="keyword">in</span> httpd.crt -noout -serial -subject</div><div class="line">sudo openssl ca -revoke ./CA/certs/httpd.crt</div></pre></td></tr></table></figure><p>revoke 后 index.txt</p><blockquote><p>R  180824075225Z  170824080136Z  01  unknown  /C=CN/ST=GD/O=youtiao/OU=dev/CN=luhaozhao/emailAddress=hzlu2010@gmail.com</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">echo</span> 序列号 &gt; /etc/pki/CA/crlnumber <span class="comment"># 生成证书吊销列表</span></div><div class="line">openssl ca -gencrl -out ./certs/httpd.crt <span class="comment"># 更新证书吊销列表</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;用对方的公钥来加密，发给对方后，对方用私钥解密&lt;/li&gt;
&lt;li&gt;用自己的私钥签名，对方收到用，用我的公钥来验证&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SSL-协议的握手过程&quot;&gt;&lt;a href=&quot;#SSL-协议的握手过程&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="openssl" scheme="http://luhaozhao.com/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>sudo</title>
    <link href="http://luhaozhao.com/2017/08/23/sudo/"/>
    <id>http://luhaozhao.com/2017/08/23/sudo/</id>
    <published>2017-08-23T15:39:23.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo -ll <span class="comment"># 显示当前sudo配置</span></div><div class="line">sudo -lU user <span class="comment"># 查看某个特定用户的设置</span></div></pre></td></tr></table></figure><h2 id="使用-visudo-修改"><a href="#使用-visudo-修改" class="headerlink" title="使用 visudo 修改"></a>使用 visudo 修改</h2><blockquote><p>/etc/sudoers 格式错误会导致 sudo 不可用，因此必须使用 visudo 编辑该文件防止出错。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">EDITOR=vim visudo <span class="comment"># 可以指定其他编辑器</span></div></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>允许某用户可以执行所有命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">用户名 ALL=(ALL) ALL</div><div class="line">deploy ALL=(ALL) NOPASSWD: ALL <span class="comment"># 无需密码</span></div></pre></td></tr></table></figure><p>只允许以某个<strong>主机名</strong>登录用户执行命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">用户名 主机名=(ALL) ALL</div></pre></td></tr></table></figure><p>允许用户组成员无密码使用sudo</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">%组名 ALL=(ALL) NOPASSWD: ALL</div></pre></td></tr></table></figure><p>不询问某个用户的密码</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Defaults:用户 !authenticate</div></pre></td></tr></table></figure><p>只为用户启用部分命令的执行权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">用户名 主机名=/sbin/halt/,/sbin/poweroff,/sbin/reboot -Syu</div><div class="line">用户名 主机名= NOPASSWD: /sbin/halt/,/sbin/poweroff,/sbin/reboot -Syu <span class="comment"># 不用输入密码</span></div></pre></td></tr></table></figure><h3 id="密码有效时间"><a href="#密码有效时间" class="headerlink" title="密码有效时间"></a>密码有效时间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Defaults:用户名 timestamp_timeout=20 <span class="comment"># 20分钟内不需要输入密码</span></div><div class="line">Defaults:用户名 timestamp_timeout=0  <span class="comment"># 0 总是询问密码</span></div></pre></td></tr></table></figure><h3 id="E-选项"><a href="#E-选项" class="headerlink" title="-E 选项"></a>-E 选项</h3><p>当前用户的环境变量不会应用到sudo启动的程序，除非使用 -E 选项</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo -E ...</div></pre></td></tr></table></figure><h3 id="sudo-与重定向"><a href="#sudo-与重定向" class="headerlink" title="sudo 与重定向"></a>sudo 与重定向</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo sh -c <span class="string">'echo xxx &gt; /etc/xxx'</span></div><div class="line"><span class="built_in">echo</span> xxx &gt; sudo tee /etc/xxx</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查看&quot;&gt;&lt;a href=&quot;#查看&quot; class=&quot;headerlink&quot; title=&quot;查看&quot;&gt;&lt;/a&gt;查看&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div clas
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="sudo" scheme="http://luhaozhao.com/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>apt 使用</title>
    <link href="http://luhaozhao.com/2017/08/23/apt/"/>
    <id>http://luhaozhao.com/2017/08/23/apt/</id>
    <published>2017-08-23T14:48:10.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get upgrade</div><div class="line">sudo apt-get install -y redis-server</div><div class="line">sudo apt-get install -y python-software-properties</div><div class="line">sudo apt-get remove redis-server</div><div class="line">sudo apt-get autoremove</div></pre></td></tr></table></figure><h2 id="dpkg-reconfigure"><a href="#dpkg-reconfigure" class="headerlink" title="dpkg-reconfigure"></a>dpkg-reconfigure</h2><p>重新配置已经安装过的软件包</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo dpkg-reconfigure locales</div></pre></td></tr></table></figure><h2 id="add-apt-repository"><a href="#add-apt-repository" class="headerlink" title="add-apt-repository"></a>add-apt-repository</h2><p>add-apt-repository is a script for <strong>adding apt sources.list entries</strong>.</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo add-apt-repository -y ppa:xxx/xxx</div><div class="line">sudo add-apt-repository --remove ppa:xxx/xxx</div></pre></td></tr></table></figure><p>可用选项</p><table><thead><tr><th>option</th><th>描述</th></tr></thead><tbody><tr><td>-h –help</td><td>显示帮助信息</td></tr><tr><td>-m –massive-debug</td><td>会显示一堆debug信息</td></tr><tr><td>-r –remove</td><td>把 sources.list.d 目录中的 repository 删除</td></tr><tr><td>-k –keyserver</td><td>keyserver</td></tr><tr><td>-y</td><td>yes</td></tr><tr><td>-s –enable-source</td><td>下载包源码</td></tr><tr><td>-u –update</td><td>添加后更新包缓存</td></tr></tbody></table><h2 id="apt-key"><a href="#apt-key" class="headerlink" title="apt-key"></a>apt-key</h2><p>用法</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">apt-key [--keyring file] [<span class="built_in">command</span>] [arguments]</div></pre></td></tr></table></figure><blockquote><p>如果没有提供 <code>keyring</code> 文件，则命令将应用在所有的 <code>keyring</code> 文件</p></blockquote><p>Manage apt’s list of trusted keys</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">apt-key add &lt;file&gt;          - add the key contained <span class="keyword">in</span> &lt;file&gt; <span class="string">'-'</span> 表示标准输入</div><div class="line">apt-key del &lt;keyid&gt;         - remove the key &lt;keyid&gt;</div><div class="line">apt-key <span class="built_in">export</span> &lt;keyid&gt;      - output the key &lt;keyid&gt;</div><div class="line">apt-key exportall           - 导出本地 trusted 数据库中的所有 key</div><div class="line">apt-key update              - 通过 keyring package 更新 key</div><div class="line">apt-key net-update          - 通过网络更新 key</div><div class="line">apt-key list                - 列出所有 key</div><div class="line">apt-key finger              - 列出所有验证指纹</div><div class="line">apt-key adv                 - 高级配置</div></pre></td></tr></table></figure><p>示例</p><p>下载并添加 virtualbox 的 key</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">wget -q http://download.virtualbox.org/virtualbox/debian/oracle_vbox.asc -O- | sudo apt-key add -</div></pre></td></tr></table></figure><h2 id="sources-list"><a href="#sources-list" class="headerlink" title="sources.list"></a>sources.list</h2><p>记录软件包仓库位置的配置文件 <code>/etc/apt/sources.list</code> <code>/etc/apt/sources.list.d/*</code></p><figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">deb <span class="string">http:</span><span class="comment">//security.ubuntu.com/ubuntu xenial-security main restricted</span></div><div class="line">deb-src <span class="string">http:</span><span class="comment">//security.ubuntu.com/ubuntu xenial-security main restricted</span></div></pre></td></tr></table></figure><p>档案类型 - 仓库地址 - 发行版 - 软件包分类</p><h3 id="档案类型"><a href="#档案类型" class="headerlink" title="档案类型"></a>档案类型</h3><ul><li>deb 二进制编译软件包</li><li>deb-src 用于编译二进制软件包的源码</li></ul><h3 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h3><p>我们可以更换为其他镜像源地址来提高下载速度</p><h3 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h3><p>有多种分类方法：</p><ul><li>发行版的具体代号 <code>xenial</code> <code>trusty</code> <code>precise</code></li><li>发行版的发行类型 <code>oldstable</code> <code>stable</code> <code>testing</code> <code>unstable</code></li><li>发行版后进一步指定 <code>xenial-security</code> <code>trusty-security</code></li></ul><h3 id="软件包分类"><a href="#软件包分类" class="headerlink" title="软件包分类"></a>软件包分类</h3><p>Ubuntu 对软件包的分类可以用下表来表示</p><table><thead><tr><th>-</th><th>自有软件</th><th>非自由软件</th></tr></thead><tbody><tr><td>官方支持的</td><td>Main</td><td>Restricted</td></tr><tr><td>非官方支持的</td><td>Universe</td><td>Multiverse</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;apt-get&quot;&gt;&lt;a href=&quot;#apt-get&quot; class=&quot;headerlink&quot; title=&quot;apt-get&quot;&gt;&lt;/a&gt;apt-get&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="apt" scheme="http://luhaozhao.com/tags/apt/"/>
    
  </entry>
  
  <entry>
    <title>Vim 备忘</title>
    <link href="http://luhaozhao.com/2017/08/22/vim/"/>
    <id>http://luhaozhao.com/2017/08/22/vim/</id>
    <published>2017-08-22T11:26:30.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<p>记录我自己不熟悉的命令</p><h2 id="基本移动操作"><a href="#基本移动操作" class="headerlink" title="基本移动操作"></a>基本移动操作</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>{</code> <code>}</code></td><td>移动到上一个、下一个段落</td></tr><tr><td><code>0</code> <code>gm</code></td><td>当前行的开头、结尾</td></tr><tr><td><code>nG</code> <code>ngg</code></td><td>移动到 <code>n</code> 行，默认是最后一个行、第一行</td></tr><tr><td><code>n%</code></td><td>移动到当前文档的百分之 <code>n</code> 的位置</td></tr><tr><td><code>n/</code></td><td>当前行第 <code>n</code> 列</td></tr><tr><td><code>Ff</code></td><td>同一行向左找字符f</td></tr><tr><td><code>ff</code></td><td>同一行向右找字符f</td></tr><tr><td><code>tf</code></td><td>移动到字符f出现的位置的前一个字符</td></tr><tr><td><code>Tf</code></td><td>移动到上一个字符f出现的位置的后一个字符</td></tr><tr><td><code>zz</code></td><td>移动屏幕使光标居中</td></tr><tr><td><code>Ctrl</code> + <code>d</code></td><td>向前滚半屏幕</td></tr><tr><td><code>Ctrl</code> + <code>u</code></td><td>向后滚半屏幕</td></tr></tbody></table><h2 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ctrl + w + s</td><td>水平分割窗口</td></tr><tr><td>ctrl + w + v</td><td>垂直分割窗口</td></tr><tr><td>ctrl + w + h/j/k/l/w</td><td>窗口切换</td></tr><tr><td>ctrl + w + q</td><td>窗口关闭</td></tr></tbody></table><h2 id="插入替换操作"><a href="#插入替换操作" class="headerlink" title="插入替换操作"></a>插入替换操作</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>ea</code></td><td>从当前<strong>单词</strong>末尾开始插入</td></tr><tr><td><code>cc</code> 或 <code>S</code></td><td>整行删除然后插入</td></tr><tr><td><code>C</code></td><td>删除光标到行尾，然后插入</td></tr><tr><td><code>s</code></td><td>改变光标下一个字符，然后插入</td></tr><tr><td><code>3&lt;&lt;</code></td><td>3行左移</td></tr><tr><td><code>3&gt;&gt;</code></td><td>3行右移</td></tr><tr><td><code>gI</code></td><td>在第一列插入</td></tr><tr><td><code>grc</code></td><td>不会影响布局</td></tr><tr><td><code>R</code></td><td></td></tr><tr><td><code>gR</code></td><td></td></tr><tr><td><code>cm</code></td><td>基于移动 <code>m</code> 改变文本</td></tr><tr><td><code>gum</code> <code>gUm</code></td><td>基于移动操作 <code>m</code> 变为小写、大写</td></tr><tr><td><code>&lt;m</code> <code>&gt;m</code></td><td></td></tr></tbody></table><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>dm</code></td><td></td></tr><tr><td><code>J</code> <code>gJ</code></td><td></td></tr><tr><td><code>:rd 回车</code></td><td></td></tr><tr><td><code>:rdx 回车</code></td><td></td></tr></tbody></table><h2 id="复制到系统剪切板"><a href="#复制到系统剪切板" class="headerlink" title="复制到系统剪切板"></a>复制到系统剪切板</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>&quot;+y</code></td><td>选中文本后输入</td></tr><tr><td><code>:w !pbcopy</code></td><td>选中文本后输入</td></tr><tr><td><code>:%w !pbcopy</code></td><td>复制整个文件</td></tr></tbody></table><h2 id="从系统剪切板中粘贴"><a href="#从系统剪切板中粘贴" class="headerlink" title="从系统剪切板中粘贴"></a>从系统剪切板中粘贴</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>&quot;+p</code></td><td>在待粘贴位置输入</td></tr><tr><td><code>:r !pbpaste</code></td><td>在待粘贴位置输入</td></tr></tbody></table><h2 id="命令模式替换文本"><a href="#命令模式替换文本" class="headerlink" title="命令模式替换文本"></a>命令模式替换文本</h2><figure class="highlight vim"><table><tr><td class="code"><pre><div class="line">:%s/<span class="built_in">line</span>/Line/gc</div></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><code>%</code></td><td>表示从第一行到最后一行，或 <code>1,5</code> 或 <code>1,$</code></td></tr><tr><td><code>c</code></td><td>表示替换需要执行确认按键</td></tr><tr><td><code>y</code></td><td>执行替换</td></tr><tr><td><code>n</code></td><td>跳过这个匹配</td></tr><tr><td><code>a</code></td><td>对这个匹配及随后的匹配字符串执行替换</td></tr><tr><td><code>q</code></td><td>或 <code>&lt;esc&gt;</code>退出替换操作</td></tr><tr><td><code>l</code></td><td>执行这次最后的替换后退出，表示 <code>last</code></td></tr><tr><td><code>C-e</code> 或 <code>C-y</code></td><td>分别向下、向上滚动，用于查看替换的上下文</td></tr></tbody></table><figure class="highlight vim"><table><tr><td class="code"><pre><div class="line">:<span class="number">1</span>,<span class="number">10</span>g/pattern/d</div></pre></td></tr></table></figure><p>从第一行到第10行满足pattern的内容执行Ex命令d</p><h2 id="大小写切换"><a href="#大小写切换" class="headerlink" title="大小写切换"></a>大小写切换</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>gu</code></td><td>选中后切换成小写</td></tr><tr><td><code>gU</code></td><td>选中后切换成大写</td></tr><tr><td><code>gJ</code></td><td>合并多行，不保留空格</td></tr></tbody></table><h2 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>o</code></td><td>切换光标到选择区开头/结尾</td></tr><tr><td><code>gv</code></td><td>切换到上一次的高亮区域</td></tr><tr><td><code>aw as ap</code></td><td>选中一个词，一个句子，一个段落</td></tr><tr><td><code>ab</code></td><td>选择被()包裹的区域</td></tr><tr><td><code>aB</code></td><td>选择被{}包裹的区域</td></tr><tr><td><code>ib</code></td><td>选择被()包裹的区域，不含括号</td></tr><tr><td><code>iB</code></td><td>选择被{}包裹的区域，不含括号</td></tr></tbody></table><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>:reg</code></td><td>显示所有寄存器的内容</td></tr><tr><td><code>&quot;a10yj</code></td><td>往下复制10行到命名寄存器 a 中</td></tr><tr><td><code>&quot;a5p</code></td><td>粘贴寄存器 a 的内容5遍</td></tr><tr><td><code>:reg a</code></td><td>显示寄存器a的内容</td></tr></tbody></table><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>qa</code></td><td>录制宏a</td></tr><tr><td><code>q</code></td><td>停止录制</td></tr><tr><td><code>@a</code></td><td>执行宏a</td></tr><tr><td><code>@@</code></td><td>重新执行上次执行的宏</td></tr><tr><td><code>:@a</code></td><td>把宏a当做Ex命令执行</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>ga</code></td><td>显示光标下的字符编码</td></tr><tr><td><code>gf</code></td><td>打开光标下的文件</td></tr><tr><td><code>g + ctrl + G</code></td><td>显示光标下的列、行位置信息</td></tr><tr><td><code>ctrl + G</code></td><td>显示文件名及位置</td></tr><tr><td><code>K</code></td><td>查看光标下的关键字man信息</td></tr><tr><td><code>ctrl + [</code></td><td>切换回normal模式</td></tr><tr><td><code>:w !sudo tee %</code></td><td>使用sudo保存当前文件</td></tr></tbody></table><ul><li>参考文档 <a href="http://tnerual.eriogerg.free.fr/vimqrc.html" target="_blank" rel="external">VIM QUICK REFERENCE CARD</a></li><li>参考文档 <a href="https://vim.rtorr.com/lang/zh_cn/" target="_blank" rel="external">VIM Cheat Sheet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录我自己不熟悉的命令&lt;/p&gt;
&lt;h2 id=&quot;基本移动操作&quot;&gt;&lt;a href=&quot;#基本移动操作&quot; class=&quot;headerlink&quot; title=&quot;基本移动操作&quot;&gt;&lt;/a&gt;基本移动操作&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="vim" scheme="http://luhaozhao.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="http://luhaozhao.com/2017/08/20/iptables/"/>
    <id>http://luhaozhao.com/2017/08/20/iptables/</id>
    <published>2017-08-20T21:54:17.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="显示当前规则"><a href="#显示当前规则" class="headerlink" title="显示当前规则"></a>显示当前规则</h2><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">iptables -vnL</div><div class="line">iptables -vnL --line-numbers <span class="comment"># 添加行号</span></div></pre></td></tr></table></figure><h2 id="重置规则"><a href="#重置规则" class="headerlink" title="重置规则"></a>重置规则</h2><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">iptables -F <span class="comment"># 刷新所有链</span></div><div class="line">iptables -X <span class="comment"># 删除所有非默认链</span></div><div class="line">iptables -t nat -F <span class="comment"># -t 指定表的链</span></div><div class="line">iptables -t nat -X</div><div class="line">iptables -t mangle -F</div><div class="line">iptables -t mangle -X</div><div class="line">iptables -t raw -F</div><div class="line">iptables -t raw -X</div><div class="line">iptables -t security -F</div><div class="line">iptables -t security -X</div><div class="line">iptables -P INPUT ACCEPT <span class="comment"># INPUT 链上的默认规则为 ACCEPT</span></div><div class="line">iptables -P FORWARD ACCEPT</div><div class="line">iptables -P OUTPUT ACCEPT</div></pre></td></tr></table></figure><h2 id="编辑规则"><a href="#编辑规则" class="headerlink" title="编辑规则"></a>编辑规则</h2><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">iptables -P FORWARD DROP <span class="comment"># 将 FORWARD 链的默认规则改为 DROP</span></div><div class="line"></div><div class="line"><span class="comment"># -A 添加规则 -p 指定协议 --dport 指定端口 -j 指定规则</span></div><div class="line">iptables -A INPUT -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable</div><div class="line"></div><div class="line"><span class="comment"># -R 替换 INPUT 链1 的规则</span></div><div class="line">iptables -R INPUT 1 -p tcp --dport 17500 ! -s 10.0.0.85 -j REJECT --reject-with icmp-port-unreachable</div><div class="line"></div><div class="line"><span class="comment"># -I 在链前插入规则 -m 指定注释</span></div><div class="line">iptables -I INPUT -p tcp --dport 17500 -s 10.0.0.85 -j ACCEPT -m comment --comment <span class="string">"Friendly Dropbox"</span></div><div class="line"></div><div class="line"><span class="comment"># 替换 INPUT 链2 的规则</span></div><div class="line">iptables -R INPUT 2 -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable</div></pre></td></tr></table></figure><h3 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h3><p>因为不会自动保存规则，因此需要手动保存</p><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">iptables-save &gt; /etc/iptables/iptables.rules</div></pre></td></tr></table></figure><p>修改后需要重新加载服务</p><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">systemtcl reload iptables</div><div class="line"></div><div class="line"><span class="comment"># 或通过 iptables 直接加载</span></div><div class="line">iptables-restore &lt; /etc/iptables/iptables.rules</div></pre></td></tr></table></figure><h2 id="规则配置文件"><a href="#规则配置文件" class="headerlink" title="规则配置文件"></a>规则配置文件</h2><p>默认存放路径 <code>/etc/iptables/iptables.rules</code> 它们不会自动加载，需要启动 <code>iptables.service</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">systemtcl <span class="built_in">enable</span> iptables.service</div><div class="line">systemtcl start iptables.service</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;显示当前规则&quot;&gt;&lt;a href=&quot;#显示当前规则&quot; class=&quot;headerlink&quot; title=&quot;显示当前规则&quot;&gt;&lt;/a&gt;显示当前规则&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="iptables" scheme="http://luhaozhao.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>SQL 函数</title>
    <link href="http://luhaozhao.com/2017/08/16/sql-aggregate/"/>
    <id>http://luhaozhao.com/2017/08/16/sql-aggregate/</id>
    <published>2017-08-16T14:03:36.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NULL-函数"><a href="#NULL-函数" class="headerlink" title="NULL 函数"></a>NULL 函数</h2><blockquote><p>NULL 值不能用等于 <code>=</code> 或 <code>!=</code> 来判断</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IFNULL(col, val) # 如果列的值为 NULL 则取值 val</div><div class="line"></div><div class="line">COALESCE(col, val)</div></pre></td></tr></table></figure><h2 id="DATETIME-类型与-TIMESTAMP-类型的区别"><a href="#DATETIME-类型与-TIMESTAMP-类型的区别" class="headerlink" title="DATETIME 类型与 TIMESTAMP 类型的区别"></a>DATETIME 类型与 TIMESTAMP 类型的区别</h2><ul><li>两种格式都会返回相同的格式 <strong>YYYY-MM-DD HH:MM:SS</strong></li></ul><blockquote><p>Timestamps in MySQL generally used to track changes to records, and are often updated every time the record is changed. If you want to store a specific value you should use a datetime field.</p><p>If you meant that you want to decide between using a UNIX timestamp or a native MySQL datetime field, go with the <strong>native format</strong>.</p><p>You can do calculations within MySQL that way</p><p><code>(&quot;SELECT DATE_ADD(my_datetime, INTERVAL 1 DAY)&quot;)</code></p><p>and it is simple to change the format of the value to a UNIX timestamp</p><p><code>(&quot;SELECT UNIX_TIMESTAMP(my_datetime)&quot;)</code></p><p>when you query the record if you want to operate on it with PHP.</p><p><a href="https://stackoverflow.com/a/409305" target="_blank" rel="external">参考</a></p></blockquote><h2 id="Aggregate-functions"><a href="#Aggregate-functions" class="headerlink" title="Aggregate functions"></a>Aggregate functions</h2><p>操作一系列的值，返回单一值，通常结合 <code>GROUP BY</code> 语句。</p><p>可以对一个以上的列应用 <code>GROUP BY</code> 语句</p><h3 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h3><h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><p>返回指定列的值的数目，<strong> NULL 不计入</strong></p><p><code>COUNT(DISTINCT col)</code> 函数返回指定列的<strong>不同值</strong>的数目</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT COUNT(DISTINCT col) FROM table_name;</div></pre></td></tr></table></figure><h3 id="FIRST"><a href="#FIRST" class="headerlink" title="FIRST"></a>FIRST</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT FIRST(col) FROM table_name;</div></pre></td></tr></table></figure><h3 id="LAST"><a href="#LAST" class="headerlink" title="LAST"></a>LAST</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT LAST(col) FROM table_name;</div></pre></td></tr></table></figure><h3 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h3><p>MAX 函数返回一列中的最大值，<strong> NULL 值不包括在计算中</strong></p><blockquote><p>MIN MAX 用于文本列中，以获得按字母顺序排列的最低或最高值</p></blockquote><h3 id="MIN"><a href="#MIN" class="headerlink" title="MIN"></a>MIN</h3><h3 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h3><h3 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h3><p>在 SQL 中增加 HAVING 子句的原因是：WHERE 关键字无法与 Aggregate function 一起使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT col1, SUM(col2) FROM table_name</div><div class="line">GROUP BY col1</div><div class="line">HAVING SUM(col2) &gt; 1000;</div></pre></td></tr></table></figure><h2 id="Scalar-functions"><a href="#Scalar-functions" class="headerlink" title="Scalar functions"></a>Scalar functions</h2><p>操作单一的值，返回单一的值。</p><h3 id="UCASE"><a href="#UCASE" class="headerlink" title="UCASE"></a>UCASE</h3><p>UCASE 函数把字段值转为大写</p><h3 id="LCASE"><a href="#LCASE" class="headerlink" title="LCASE"></a>LCASE</h3><p>LCASE 函数把字段值转为小写</p><h3 id="MID"><a href="#MID" class="headerlink" title="MID"></a>MID</h3><p>用于从文本字段中提取字符</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT MID(col, start[, length]) FROM table_name;</div></pre></td></tr></table></figure><ul><li>col 必需，要提取字符的字段</li><li>start 必需，开始的位置，从1开始</li><li>length 可选，返回字符数</li></ul><h3 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH"></a>LENGTH</h3><p>返回文本字段值的长度</p><h3 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND"></a>ROUND</h3><p>把数值字段舍入指定的小数位数</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT ROUND(col, decimals) FROM table_name;</div></pre></td></tr></table></figure><ul><li>col 必需</li><li>decimals 可选，保留的小数位数</li></ul><h2 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h2><h3 id="TIMESTAMPDIFF"><a href="#TIMESTAMPDIFF" class="headerlink" title="TIMESTAMPDIFF"></a>TIMESTAMPDIFF</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT TIMESTAMPDIFF(DAY, updatedAt, CURDATE()) as days from admins;</div></pre></td></tr></table></figure><ul><li>unit 比较的单位 SECOND / MINUTE / HOUR / DAY / MONTH / YEAR</li><li>from_time 比较的开始时间</li><li>to_time 比较的结束时间</li></ul><h3 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF"></a>DATEDIFF</h3><p>DATEDIFF(expr1, expr2) returns <code>expr1 - expr2</code> expressed as a value in days.</p><h3 id="YEAR-MONTH-DAY-DATE-TIME"><a href="#YEAR-MONTH-DAY-DATE-TIME" class="headerlink" title="YEAR / MONTH / DAY / DATE / TIME"></a>YEAR / MONTH / DAY / DATE / TIME</h3><p>exrtract specific part of the column.</p><p><strong>注意 DATE 函数是提取日期部分</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 找出下个月生日的宠物</div><div class="line">SELECT name, birth FROM pet</div><div class="line">WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(), INTERVAL 1 MONTH));</div><div class="line"></div><div class="line"># 另一方法，使用 MOD 函数</div><div class="line">SELECT name, birth FROM pet</div><div class="line">WHERE MONTH(birth) = MOD(MONTH(CURDATE()), 12) + 1;</div></pre></td></tr></table></figure><h3 id="CONVERT-TZ"><a href="#CONVERT-TZ" class="headerlink" title="CONVERT_TZ"></a>CONVERT_TZ</h3><p>时区转换</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT CONVERT_TZ(&apos;2017-08-15 01:00:00&apos;, &apos;+00:00&apos;, &apos;+08:00&apos;);</div></pre></td></tr></table></figure><h3 id="ADDDATE-SUBDATE"><a href="#ADDDATE-SUBDATE" class="headerlink" title="ADDDATE / SUBDATE"></a>ADDDATE / SUBDATE</h3><p>语法：</p><ul><li><code>ADDDATE(date, INTERVAL n unit)</code></li><li><code>ADDDATE(expr, days)</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT DATE_ADD(&apos;2008-01-02&apos;, INTERVAL 31 DAY);</div><div class="line"> -&gt; &apos;2008-02-02&apos;</div><div class="line">SELECT ADDDATE(&apos;2008-01-02&apos;, INTERVAL 31 DAY);</div><div class="line"> -&gt; &apos;2008-02-02&apos;</div><div class="line">SELECT ADDDATE(&apos;2008-01-02&apos;, 31);</div><div class="line"> -&gt; &apos;2008-02-02&apos;</div></pre></td></tr></table></figure><p>同义词：</p><ul><li><code>ADDDATE</code> / <code>DATE_ADD</code></li><li><code>SUBDATE</code> / <code>DATE_SUB</code></li></ul><h3 id="ADDTIME"><a href="#ADDTIME" class="headerlink" title="ADDTIME"></a>ADDTIME</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT ADDTIME(&apos;2007-12-31 23:59:59.999999&apos;, &apos;1 1:1:1.000002&apos;);</div><div class="line"> -&gt; &apos;2008-01-02 01:01:01.000001&apos;</div><div class="line">SELECT ADDTIME(&apos;01:00:00.999999&apos;, &apos;02:00:00.999998&apos;);</div><div class="line"> -&gt; &apos;03:00:01.999997&apos;</div></pre></td></tr></table></figure><h3 id="NOW-CURDATE-CURTIME"><a href="#NOW-CURDATE-CURTIME" class="headerlink" title="NOW / CURDATE / CURTIME /"></a>NOW / CURDATE / CURTIME /</h3><p>同义词：</p><ul><li><code>CURRENT_DATE</code> / <code>CURDATE</code></li><li><code>CURRENT_TIME</code> / <code>CURTIME</code></li><li><code>CURRENT_TIMESTAMP</code> / <code>NOW</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT NOW();</div><div class="line">SELECT CURDATE();</div><div class="line">SELECT CURTIME();</div></pre></td></tr></table></figure><h3 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT"></a>DATE_FORMAT</h3><p>格式化函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT DATE_FORMAT(NOW(), &apos;%Y-%m-%d %H:%i:%S&apos;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NULL-函数&quot;&gt;&lt;a href=&quot;#NULL-函数&quot; class=&quot;headerlink&quot; title=&quot;NULL 函数&quot;&gt;&lt;/a&gt;NULL 函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;NULL 值不能用等于 &lt;code&gt;=&lt;/code&gt; 或 &lt;code&gt;!=
      
    
    </summary>
    
      <category term="数据库" scheme="http://luhaozhao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="sql" scheme="http://luhaozhao.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://luhaozhao.com/2017/08/14/sql/"/>
    <id>http://luhaozhao.com/2017/08/14/sql/</id>
    <published>2017-08-14T18:06:41.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器元数据"><a href="#服务器元数据" class="headerlink" title="服务器元数据"></a>服务器元数据</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>SELECT VERSION()</code></td><td>版本信息</td></tr><tr><td><code>SELECT DATABASE()</code></td><td>当前数据库名</td></tr><tr><td><code>SELECT USER()</code></td><td>当前用户名</td></tr><tr><td><code>SHOW STATUS</code></td><td>服务器状态</td></tr><tr><td><code>SHOW VARIABLES</code></td><td>配置变量</td></tr></tbody></table><h2 id="描述表结构"><a href="#描述表结构" class="headerlink" title="描述表结构"></a>描述表结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DESCRIBE table_name;</div><div class="line">SHOW CREATE TABLE table_name;</div><div class="line">SHOW COLUMNS FROM table_name;</div><div class="line">SHOW INDEX FROM table_name;</div><div class="line">SHOW TABLE STATUS LIKE &apos;table_name&apos;\G</div></pre></td></tr></table></figure><h2 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 添加列</div><div class="line">ALTER TABLE table_name</div><div class="line">ADD column_name datatype;</div><div class="line"></div><div class="line"># 删除列</div><div class="line">ALTER TABLE table_name</div><div class="line">DROP COLUMN column_name;</div><div class="line"></div><div class="line"># 修改列的数据类型</div><div class="line">ALTER TABLE table_name</div><div class="line">CHANGE COLUMN old_col new_col datatype;</div><div class="line"></div><div class="line"># 改变 AUTO_INCREMENT 的起始值</div><div class="line">ALTER TABLE table_name AUTO_INCREMENT=100;</div></pre></td></tr></table></figure><h2 id="CONSTRAINT"><a href="#CONSTRAINT" class="headerlink" title="CONSTRAINT"></a>CONSTRAINT</h2><h3 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ALTER TABLE table_name</div><div class="line">ADD PRIMARY KEY (col);</div><div class="line"># 或多个列定义</div><div class="line">ADD CONSTRAINT pk_name PRIMARY KEY (col1,col2);</div></pre></td></tr></table></figure><p>撤销 PRIMARY KEY 约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ALTER TABLE table_name</div><div class="line">DROP PRIMARY KEY;</div></pre></td></tr></table></figure><h3 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h3><p>a unique constrait is also an <strong>index</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ALTER TABLE table_name</div><div class="line">ADD UNIQUE (col);</div><div class="line"># 或命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束</div><div class="line">ADD CONSTRAINT constraint_name UNIQUE (col1,col2);</div></pre></td></tr></table></figure><p>要 drop 掉表中的唯一约束先要找出索引的名字，<code>Key_name</code> 便是索引的名字</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SHOW INDEX FROM table_name;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DROP INDEX index_name ON table_name;</div><div class="line"># 或者使用 alter 语法</div><div class="line">ALTER TABLE table_name</div><div class="line">DROP INDEX index_name;</div></pre></td></tr></table></figure><h3 id="INDEX"><a href="#INDEX" class="headerlink" title="INDEX"></a>INDEX</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE INDEX index_name</div><div class="line">ON table_name(col1,col2);</div><div class="line"></div><div class="line"># 创建唯一索引</div><div class="line">CREATE UNIQUE INDEX index_name</div><div class="line">ON table_name(column_name);</div></pre></td></tr></table></figure><p>使用 <code>ALTER</code> 命令添加索引</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ALTER TABLE table_name ADD PRIMARY KEY (col...);</div><div class="line"></div><div class="line"># 唯一索引，指定索引长度</div><div class="line">ALTER TABLE table_name ADD UNIQUE index_name (col(20));</div><div class="line"></div><div class="line">ALTER TABLE table_name ADD INDEX index_name (col...);</div><div class="line"></div><div class="line"># 全文索引</div><div class="line">ALTER TABLE table_name ADD FULLTEXT index_name (col...);</div></pre></td></tr></table></figure><h4 id="使用全文索引语法"><a href="#使用全文索引语法" class="headerlink" title="使用全文索引语法"></a>使用全文索引语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT * FROM table_name</div><div class="line">WHERE MATCH(`col1`, `col2`) AGAINST(&apos;foo bar&apos;);</div></pre></td></tr></table></figure><h3 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h3><p>外键约束能防止非法数据插入外键列，它必须是它指向的那个表中的值之一</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE orders</div><div class="line">(</div><div class="line">o_id int NOT NULL,</div><div class="line">order_no int NOT NULL,</div><div class="line">u_id int,</div><div class="line">PRIMARY KEY (o_id),</div><div class="line">FOREIGN KEY (u_id) REFERENCES users(u_id)</div><div class="line"># 或命名外键</div><div class="line">CONSTRAINT fk_name FOREIGN KEY (u_id) REFERENCES users(u_id) ON DELETE CASCADE</div><div class="line">)</div></pre></td></tr></table></figure><p>已经存在表后添加外键约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ALTER TABLE table_name</div><div class="line">ADD CONSTRAINT fk_name</div><div class="line">FOREIGN KEY (u_id)</div><div class="line">REFERENCES users(u_id);</div></pre></td></tr></table></figure><p>drop 掉外键约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ALTER TABLE table_name</div><div class="line">DROP FOREIGN KEY fk_name;</div></pre></td></tr></table></figure><h3 id="CHECK"><a href="#CHECK" class="headerlink" title="CHECK"></a>CHECK</h3><p>限制列中的值的范围</p><blockquote><p>MySQL 不支持 check 约束，可以定义约束，但不会起作用<br>PostgreSQL 支持</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE table_name</div><div class="line">(</div><div class="line">...</div><div class="line">CHECK (col1 &gt; 0)</div><div class="line">CONSTRAINT check_name CHECK (col2 &gt; 0 AND col3 = &apos;foo&apos;)</div><div class="line">)</div></pre></td></tr></table></figure><p>已存在的表添加 CHECK 约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ALTER TABLE table_name</div><div class="line">ADD CHECK (col1 &gt; 0);</div><div class="line"># 或命名 check</div><div class="line">CONSTRAINT check_name CHECK (col2 &gt; 0 AND col3 = &apos;foo&apos;)</div><div class="line">)</div></pre></td></tr></table></figure><p>drop 掉 check 约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ALTER TABLE table_name</div><div class="line">DROP CHECK check_name;</div><div class="line"># 或</div><div class="line">DROP CONSTRAINT check_name;</div></pre></td></tr></table></figure><h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ALTER TABLE table_name</div><div class="line">ALTER col SET DEFAULT &apos;value&apos;;</div><div class="line"># 或</div><div class="line">ALTER COLUMN col SET DEFAULT &apos;value&apos;;</div></pre></td></tr></table></figure><p>drop DEFAULT</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">alter table table_name</div><div class="line">alter col DROP DEFAULT;</div><div class="line"># 或</div><div class="line">alter column col DROP DEFAULT;</div></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE VIEW view_name AS</div><div class="line">SELECT col1,col2 FROM table_name;</div><div class="line"></div><div class="line">SHOW CREATE TABLE view_name;</div><div class="line">SHOW CREATE VIEW view_name;</div><div class="line"></div><div class="line">ALTER VIEW view_name AS new_defination...;</div><div class="line"></div><div class="line">DROP VIEW view_name;</div></pre></td></tr></table></figure><h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 添加用户</div><div class="line">INSERT INTO user</div><div class="line">(host, user, password, select_priv)</div><div class="line">VALUES</div><div class="line">(&apos;localhost&apos;, &apos;foo&apos;, PASSWORD(&apos;password&apos;), &apos;Y&apos;);</div><div class="line"></div><div class="line"># 添加用户</div><div class="line">CREATE USER &apos;foo&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;;</div><div class="line"></div><div class="line"># 添加用户并指定权限</div><div class="line">GRANT ALL PRIVILEGES</div><div class="line">ON some_db.*</div><div class="line">To &apos;user&apos;@&apos;localhost&apos;</div><div class="line">IDENTIFIED BY &apos;password&apos;;</div><div class="line"></div><div class="line">GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP</div><div class="line">ON some_db.*</div><div class="line">TO &apos;foo&apos;@&apos;localhost&apos;</div><div class="line">IDENTIFIED BY &apos;password&apos;;</div><div class="line"></div><div class="line"># 显示用户权限</div><div class="line">SHOW GRANTS FOR &apos;root&apos;@&apos;localhost&apos;;</div><div class="line"></div><div class="line"># 删除用户</div><div class="line">DROP USER &apos;foo&apos;@&apos;localhost&apos;;</div></pre></td></tr></table></figure><h3 id="重新载入授权表"><a href="#重新载入授权表" class="headerlink" title="重新载入授权表"></a>重新载入授权表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">FLUSH PRIVILEGES;</div></pre></td></tr></table></figure><h3 id="查看安全策略"><a href="#查看安全策略" class="headerlink" title="查看安全策略"></a>查看安全策略</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SHOW VARIABLES LIKE &apos;validate_password%&apos; ;</div><div class="line"></div><div class="line"># 改变变量值</div><div class="line">SET GLOBAL variable=value;</div></pre></td></tr></table></figure><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p>不同于 <code>LIKE</code> 使用 <code>REGEXP</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT col FROM table_name</div><div class="line">WHERE col REGEXP &apos;^foo.&#123;3&#125;$&apos;;</div></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>只有使用了 <code>Innodb</code> 数据库引擎的数据库或表才支持事务。</p></blockquote><h2 id="创建临时表"><a href="#创建临时表" class="headerlink" title="创建临时表"></a>创建临时表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TEMPORARY TABLE table_name</div><div class="line">(</div><div class="line">...</div><div class="line">)</div></pre></td></tr></table></figure><h2 id="复制表的思路"><a href="#复制表的思路" class="headerlink" title="复制表的思路"></a>复制表的思路</h2><ol><li>使用 <code>SHOW CREATE TABLE table_name \G</code> 获取表完整结构；</li><li>修改SQL 语句的表名，并执行创建新表；</li><li>执行 <code>INSERT INTO ... SELECT</code> 复制完整数据</li></ol><h3 id="通过复制表删除重复数据"><a href="#通过复制表删除重复数据" class="headerlink" title="通过复制表删除重复数据"></a>通过复制表删除重复数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE tmp</div><div class="line">SELECT col1, col2, ...</div><div class="line">FROM table_name</div><div class="line">GROUP BY (col1, col2, ...);</div><div class="line"></div><div class="line">DROP TABLE table_name;</div><div class="line"></div><div class="line">ALTER TABLE tmp RENAME TO table_name;</div></pre></td></tr></table></figure><h2 id="导出导入数据"><a href="#导出导入数据" class="headerlink" title="导出导入数据"></a>导出导入数据</h2><h3 id="SELECT-INTO-OUTFILE"><a href="#SELECT-INTO-OUTFILE" class="headerlink" title="SELECT INTO OUTFILE"></a>SELECT INTO OUTFILE</h3><p>指定分隔符，导出成 CSV 格式</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT * FROM table_name</div><div class="line">INTO OUTFILE &apos;/path/to/file.txt&apos;</div><div class="line">FIELDS TERMINATED BY &apos;,&apos;</div><div class="line">OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</div><div class="line">LINES TERMINATED BY &apos;\r\n&apos;;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE table_name;</div></pre></td></tr></table></figure><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ mysqldump -u user -p database [table_name] &gt; dump.sql</div><div class="line">$ mysqldump -u user -p --no-create-info database [table_name] &gt; dump.sql</div><div class="line">$ mysqldump -u user -p --all-databases &gt; dump.sql</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务器元数据&quot;&gt;&lt;a href=&quot;#服务器元数据&quot; class=&quot;headerlink&quot; title=&quot;服务器元数据&quot;&gt;&lt;/a&gt;服务器元数据&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thea
      
    
    </summary>
    
      <category term="数据库" scheme="http://luhaozhao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="sql" scheme="http://luhaozhao.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>RVM 使用</title>
    <link href="http://luhaozhao.com/2017/08/13/rvm/"/>
    <id>http://luhaozhao.com/2017/08/13/rvm/</id>
    <published>2017-08-13T14:51:14.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>rvm get stable</code></td><td>更新RVM</td></tr><tr><td><code>rvm reload</code></td><td>重新加载</td></tr><tr><td><code>rvm list known</code></td><td>列出已知的 Ruby 版本</td></tr><tr><td><code>rvm install x.x.x</code></td><td>安装一个 Ruby 版本</td></tr><tr><td><code>rvm remove x.x.x</code></td><td>卸载一个 Ruby 版本</td></tr><tr><td><code>rvm list</code></td><td>列出已经安装的 Ruby 版本</td></tr><tr><td><code>rvm gemset list</code></td><td>当前 Ruby 版本可用的 gemset 列表</td></tr><tr><td><code>rvm gemset create learn-rails</code></td><td>创建 gemset</td></tr><tr><td><code>rvm gemset use global</code></td><td>切换 <code>gemset</code></td></tr><tr><td><code>rvm gemset use default</code></td><td>切换 <code>gemset</code></td></tr><tr><td><code>rvm gemset empty &lt;gemset&gt;</code></td><td>清空 gemset 中的 gem</td></tr><tr><td><code>rvm gemset delete &lt;gemset&gt;</code></td><td>删除 gemset</td></tr><tr><td><code>gem install rails</code></td><td>把 <code>gem</code> <strong>rails</strong> 安装到当前 gemset 中</td></tr><tr><td><code>gem list</code></td><td>查看当前 gemset 安装了哪些 gem</td></tr><tr><td><code>gem sources -l</code></td><td>查看源列表</td></tr><tr><td><code>gem sources --remove https://rubygems.org</code></td><td>删除源</td></tr><tr><td><code>gem sources -a https://ruby.taobao.org</code></td><td>添加淘宝源</td></tr></tbody></table><h2 id="RVM-给项目预加载特定-Ruby-版本和-gemset-设置"><a href="#RVM-给项目预加载特定-Ruby-版本和-gemset-设置" class="headerlink" title="RVM 给项目预加载特定 Ruby 版本和 gemset 设置"></a><code>RVM</code> 给项目预加载特定 Ruby 版本和 gemset 设置</h2><p>到项目目录下建立 <code>.rvmrc</code> 文件，在文件中加入命令 <code>rvm use ruby2.1.4@gemset-name</code><br>以后只要切到这个目录，RVM 都会自动加载指定的版本和 <code>gemset</code><br><strong> 该文件要记得添加到 <code>.gitignore</code> 中。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbod
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ruby" scheme="http://luhaozhao.com/tags/ruby/"/>
    
      <category term="rvm" scheme="http://luhaozhao.com/tags/rvm/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2 操作小结</title>
    <link href="http://luhaozhao.com/2017/08/13/iterm2/"/>
    <id>http://luhaozhao.com/2017/08/13/iterm2/</id>
    <published>2017-08-13T13:41:05.000Z</published>
    <updated>2018-06-27T08:07:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标签页与窗口"><a href="#标签页与窗口" class="headerlink" title="标签页与窗口"></a>标签页与窗口</h2><table><thead><tr><th><strong>功能</strong></th><th><strong>快捷方式</strong></th></tr></thead><tbody><tr><td>前一个标签页</td><td><code>⌘</code>+ <code>←</code></td></tr><tr><td>后一个标签页</td><td><code>⌘</code>+ <code>→</code></td></tr><tr><td>切换到标签页</td><td><code>⌘</code> + <code>Number</code></td></tr><tr><td>切换到窗口</td><td><code>⌘</code> + <code>Option</code> + <code>Number</code></td></tr><tr><td>根据方向切换到面板</td><td><code>⌘</code> + <code>Option</code> + <code>方向键</code></td></tr><tr><td>切换到使用过的面板</td><td><code>⌘</code> + <code>]</code> , <code>⌘</code> + <code>[</code></td></tr><tr><td>水平切分窗口 (same profile)</td><td><code>⌘</code> + <code>Option</code> + <code>d</code></td></tr><tr><td>垂直切分窗口 (same profile)</td><td><code>⌘</code> + <code>d</code></td></tr><tr><td>Set Mark</td><td><code>⌘</code> + <code>M</code></td></tr><tr><td>Jump to Mark</td><td><code>⌘</code> + <code>J</code></td></tr><tr><td>Split Window Horizontally (new profile)</td><td><code>Option</code> + <code>⌘</code> + <code>H</code></td></tr><tr><td>Split Window Vertically (new profile)</td><td><code>Option</code> + <code>⌘</code> + <code>V</code></td></tr></tbody></table><h2 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h2><table><thead><tr><th><strong>功能</strong></th><th><strong>快捷方式</strong></th></tr></thead><tbody><tr><td>移动到行首</td><td><code>Ctrl</code> + <code>a</code></td></tr><tr><td>移动到行尾</td><td><code>Ctrl</code> + <code>e</code></td></tr><tr><td>向后移动字符</td><td><code>Ctrl</code> + <code>b</code></td></tr><tr><td>向前移动字符</td><td><code>Ctrl</code> + <code>f</code></td></tr><tr><td>向前移动一个词</td><td><code>Option</code> + <code>f</code></td></tr><tr><td>向后移动一个词</td><td><code>Option</code> + <code>b</code></td></tr></tbody></table><p><strong> 需要先设置 <code>Option</code> 键为 <code>+Esc</code> ，在 <code>Preferences &gt; Profiles &gt; Keys</code> 中设置 </strong></p><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><table><thead><tr><th><strong>功能</strong></th><th><strong>快捷方式</strong></th></tr></thead><tbody><tr><td>删除当前字符</td><td><code>Ctrl</code> + <code>d</code></td></tr><tr><td>向前删除字符</td><td><code>Ctrl</code> + <code>h</code></td></tr><tr><td>向前删除单词</td><td><code>Ctrl</code> + <code>w</code> 或 <code>Option</code> + <code>Backspace</code></td></tr><tr><td>向后删除单词</td><td><code>Option</code> + <code>d</code></td></tr><tr><td>删除到行尾</td><td><code>Ctrl</code> + <code>k</code></td></tr><tr><td>删除整行</td><td><code>Ctrl</code> + <code>u</code></td></tr></tbody></table><h2 id="粘贴命令"><a href="#粘贴命令" class="headerlink" title="粘贴命令"></a>粘贴命令</h2><table><thead><tr><th><strong>功能</strong></th><th><strong>快捷方式</strong></th></tr></thead><tbody><tr><td>Loop through and paste previously cut text</td><td><code>Option</code> + <code>y</code></td></tr><tr><td>Loop through and paste the last argument of previous commands</td><td><code>Option</code> + <code>.</code></td></tr></tbody></table><h2 id="清屏与撤销命令"><a href="#清屏与撤销命令" class="headerlink" title="清屏与撤销命令"></a>清屏与撤销命令</h2><table><thead><tr><th><strong>功能</strong></th><th><strong>快捷方式</strong></th></tr></thead><tbody><tr><td>清屏</td><td><code>⌘</code> + <code>r</code> 或 <code>Ctrl</code> +<code>l</code></td></tr><tr><td>清除当前窗口buffer</td><td><code>⌘</code> + <code>k</code></td></tr><tr><td>撤销操作</td><td><code>Ctrl</code> + <code>-</code></td></tr></tbody></table><h2 id="搜索与历史命令"><a href="#搜索与历史命令" class="headerlink" title="搜索与历史命令"></a>搜索与历史命令</h2><table><thead><tr><th><strong>功能</strong></th><th><strong>快捷方式</strong></th></tr></thead><tbody><tr><td>历史输入搜索</td><td><code>Ctrl</code> + <code>r</code> 输入搜索命令; 重复触发 <code>Ctrl</code> + <code>r</code> 遍历结果</td></tr><tr><td>最后记住的搜索命令</td><td>重复输入 <code>Ctrl</code> + <code>r</code></td></tr><tr><td>End the search at current history entry</td><td><code>Ctrl</code> + <code>y</code></td></tr><tr><td>取消搜索并返回原始命令</td><td><code>Ctrl</code> + <code>g</code></td></tr><tr><td>上一条命令</td><td><code>Ctrl</code> + <code>p</code></td></tr><tr><td>弹出历史命令选项列表</td><td><code>⌘</code> + <code>;</code></td></tr><tr><td>弹出剪切板</td><td><code>⌘</code> + <code>shift</code> + <code>h</code></td></tr><tr><td>扩展搜索匹配</td><td><code>tab</code> 向后扩展搜索匹配，<code>shift</code> + <code>tab</code>向前扩展</td></tr><tr><td>把匹配粘贴到输入行</td><td><code>option</code> + <code>enter</code></td></tr><tr><td>进入回放模式</td><td><code>cmd</code> + <code>option</code> + <code>b</code></td></tr><tr><td>进入<strong>espose tab</strong> 模式</td><td><code>cmd</code> + <code>option</code> + <code>e</code></td></tr><tr><td>高亮当前光标位置</td><td><code>⌘</code> + <code>/</code></td></tr><tr><td>高亮当前光标行</td><td><code>⌘</code> + <code>alt</code> + <code>;</code></td></tr><tr><td>显示右侧时间栏</td><td><code>⌘</code> + <code>shift</code> + <code>e</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标签页与窗口&quot;&gt;&lt;a href=&quot;#标签页与窗口&quot; class=&quot;headerlink&quot; title=&quot;标签页与窗口&quot;&gt;&lt;/a&gt;标签页与窗口&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;st
      
    
    </summary>
    
      <category term="命令行工具" scheme="http://luhaozhao.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="iterm2" scheme="http://luhaozhao.com/tags/iterm2/"/>
    
  </entry>
  
</feed>
